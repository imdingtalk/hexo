<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浪潮服务器安装esxi6.5报错nfs41client failed to load</title>
    <url>/2019/12/29/yuque/%E6%B5%AA%E6%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85esxi6.5%E6%8A%A5%E9%94%99nfs41client%20failed%20to%20load/</url>
    <content><![CDATA[<p><a name="kURvs"></a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用浪潮M5服务器安装esxi6.5版本，加载相关项过程中报错nfs41client failed to load<br><a name="fw7TS"></a></p>
<h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>百度了下，这个是网卡驱动的问题，服务器配置的是intel x722 for 1GB的网卡，百度了半天，使用百度的办法试了几次都不行，最后Google了一下 intel x722 driver esxi。。问题就解决了。<br>怎么查找esxi的的兼容性驱动，Intel给了方法：<a href="https://www.intel.com/content/www/us/en/support/articles/000005693/network-and-io/ethernet-products.html" target="_blank" rel="noopener">https://www.intel.com/content/www/us/en/support/articles/000005693/network-and-io/ethernet-products.html</a>   <br>最终找到的驱动：<a href="https://my.vmware.com/cn/group/vmware/details?downloadGroup=DT-ESX65-INTEL-I40EN-195&amp;productId=614" target="_blank" rel="noopener">https://my.vmware.com/cn/group/vmware/details?downloadGroup=DT-ESX65-INTEL-I40EN-195&amp;productId=614</a></p>
<p>使用ESXI-customizer-v2.7.2（附件） 给默认的6.5镜像注入驱动，然后使用这个自定义的驱动再去安装就没有问题了</p>
<p><a href="https://www.yuque.com/attachments/yuque/0/2019/rar/148941/1577614444066-3e6a646a-5fe6-4444-92a7-66315400c944.rar?_lake_card=%7B%22uid%22%3A%221577614436599-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2019%2Frar%2F148941%2F1577614444066-3e6a646a-5fe6-4444-92a7-66315400c944.rar%22%2C%22name%22%3A%22ESXi-Customizer-v2.7.2.rar%22%2C%22size%22%3A2506536%2C%22type%22%3A%22%22%2C%22ext%22%3A%22rar%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22XwQ16%22%2C%22card%22%3A%22file%22%7D" target="_blank" rel="noopener">ESXi-Customizer-v2.7.2.rar</a></p>
<p><a name="BlgwC"></a></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>新版的服务器使用的是新的网卡，老的镜像默认没有自带对新网络的驱动</p>
]]></content>
  </entry>
  <entry>
    <title>k8s中的强制删除-pod or namespace</title>
    <url>/2019/12/11/yuque/k8s%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4-pod%20or%20namespace/</url>
    <content><![CDATA[<p><a name="ABPjR"></a></p>
<h3 id="1-强制删除"><a href="#1-强制删除" class="headerlink" title="1. 强制删除"></a>1. 强制删除</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete namespace &lt;NAMESPACE&gt; --force --grace-period=0</span><br></pre></td></tr></table></figure>
<p><a name="J2lOF"></a></p>
<h3 id="2-使用API操作"><a href="#2-使用API操作" class="headerlink" title="2. 使用API操作"></a>2. 使用API操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl proxy &amp;</span><br><span class="line">NAMESPACE=monitoring</span><br><span class="line">kubectl get namespace $NAMESPACE -o json |jq &apos;.spec = &#123;&quot;finalizers&quot;:[]&#125;&apos; &gt;temp.json</span><br><span class="line">curl -k -H &quot;Content-Type: application/json&quot; -X PUT --data-binary @temp.json 127.0.0.1:8001/api/v1/namespaces/$NAMESPACE/finalize</span><br></pre></td></tr></table></figure>
<p><a name="7nTgH"></a></p>
<h3 id="3-在etcd中删除"><a href="#3-在etcd中删除" class="headerlink" title="3. 在etcd中删除"></a>3. 在etcd中删除</h3><p>查看<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl get /registry/namespaces --prefix --keys-only \</span><br><span class="line">	--cert /etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">	--key /etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">	--cacert /etc/kubernetes/pki/etcd/ca.crt</span><br></pre></td></tr></table></figure></p>
<p>删除<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl del /registry/namespaces/&lt;NAMESPACE&gt; \</span><br><span class="line">	--cert /etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">	--key /etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">	--cacert /etc/kubernetes/pki/etcd/ca.crt</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Pod同理</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>centos更改网卡设置的名称</title>
    <url>/2019/12/10/yuque/centos%E6%9B%B4%E6%94%B9%E7%BD%91%E5%8D%A1%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<p>1.在  /etc/sysconfig/network-scirpts/  mv ifcfg-ens192 ifcfg-eth0 然后  vim ifcfg-eth0 把DEVICE改成 DEVICE=eth0 保存<br>2.  /etc/sysconfig/grub 下的 GRUB_COMLINE_LINUX=”” 中添加 net.ifnames=0 biosdevname=0 ”  //禁用eno1*<br>3. 执行  grub2-mkconfig -o /boot/grub2/grub.cfg 更新grub2文件<br>4.reboot</p>
]]></content>
  </entry>
  <entry>
    <title>influxdb相关的</title>
    <url>/2019/12/09/yuque/influxdb%E7%9B%B8%E5%85%B3%E7%9A%84/</url>
    <content><![CDATA[<p><a name="743pK"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a name="nkUnA"></a></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>InfluxDB是一个由InfluxData开发的开源时序型数据。它由Go写成，着力于高性能地查询与存储时序型数据。InfluxDB被广泛应用于存储系统的监控数据，IoT行业的实时数据等场景  </p>
<p>与传统数据库中的名词做比较  </p>
<table>
<thead>
<tr>
<th>influxDB中的名词</th>
<th>传统数据库中的概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>measurement</td>
<td>数据库中的表</td>
</tr>
<tr>
<td>points</td>
<td>表里面的一行数据</td>
</tr>
</tbody>
</table>
<p>Points  </p>
<p>Point由时间戳（time）、数据（field）、标签（tags）组成。    <br>Point相当于传统数据库里的一行数据，如下表所示：</p>
<table>
<thead>
<tr>
<th>Point属性</th>
<th>传统数据库中的概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>time</td>
<td>每个数据记录时间，是数据库中的主索引(会自动生成)</td>
</tr>
<tr>
<td>fields</td>
<td>各种记录值（没有索引的属性）</td>
</tr>
<tr>
<td>tags</td>
<td>各种有索引的属性</td>
</tr>
</tbody>
</table>
<p><a name="SMNx7"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>参考：<a href="https://portal.influxdata.com/downloads/" target="_blank" rel="noopener">https://portal.influxdata.com/downloads/</a>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://dl.influxdata.com/influxdb/releases/influxdb-1.7.9.x86_64.rpm</span><br><span class="line">sudo yum localinstall influxdb-1.7.9.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>默认的安装信息  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll /usr/bin/influ*</span><br><span class="line">influxd            # influxdb服务器</span><br><span class="line">influx             # influxdb命令行客户端</span><br><span class="line">influx_inspect     # 查看工具</span><br><span class="line">influx_stress      # 压力测试工具</span><br><span class="line">influx_tsm         # 数据库转换工具（将数据库从b1或bz1格式转换为tsm1格式）</span><br><span class="line"></span><br><span class="line">ll /var/lib/influxdb/</span><br><span class="line">data               # 存放最终存储的数据，文件以.tsm结尾</span><br><span class="line">meta               # 存放数据库元数据</span><br><span class="line">wal                # 存放预写日志文件</span><br></pre></td></tr></table></figure>
<p><strong>端口说明  </strong><br>  <br>8086：数据写入influxdb的地址，8086为默认端口；  <br>8088：TCP端口8088可用于RPC服务执行备份和还原操作。<br><a name="PjugL"></a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>用户常用的一些InfluxQL  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 查看所有的数据库</span><br><span class="line">show databases;</span><br><span class="line">-- 使用特定的数据库</span><br><span class="line">use database_name;</span><br><span class="line">-- 查看所有的measurement</span><br><span class="line">show measurements;</span><br><span class="line">-- 查询10条数据</span><br><span class="line">select * from measurement_name limit 10;</span><br><span class="line">-- 数据中的时间字段默认显示的是一个纳秒时间戳，改成可读格式</span><br><span class="line">precision rfc3339; -- 之后再查询，时间就是rfc3339标准格式</span><br><span class="line">-- 或可以在连接数据库的时候，直接带该参数</span><br><span class="line">influx -precision rfc3339</span><br><span class="line">-- 查看一个measurement中所有的tag key </span><br><span class="line">show tag keys</span><br><span class="line">-- 查看一个measurement中所有的field key </span><br><span class="line">show field keys</span><br><span class="line">-- 查看一个measurement中所有的保存策略(可以有多个，一个标识为default)</span><br><span class="line">show retention policies;</span><br><span class="line">show retention policies on &quot;db_name&quot;; </span><br><span class="line">-- 创建新的策略  </span><br><span class="line">create retention policy &quot;rp_name&quot; on &quot;db_name&quot; duration 3w replication 1 default</span><br><span class="line">-- rp_name：策略名；</span><br><span class="line">-- db_name：具体的数据库名；</span><br><span class="line">-- 3w：保存3周，3周之前的数据将被删除，influxdb具有各种事件参数，比如：h（小时），d（天），w（星期）；</span><br><span class="line">-- replication 1：副本个数，一般为1就可以了；</span><br><span class="line">-- default：设置为默认策略  </span><br><span class="line">-- 修改Retention Policies  </span><br><span class="line">alter retention policy &quot;rp_name&quot; on &quot;db_name&quot; duration 30d default</span><br><span class="line">-- 删除Retention Policies</span><br><span class="line">drop retention policy &quot;rp_name&quot; on &quot;db_name&quot;</span><br></pre></td></tr></table></figure>
<p>管理&amp;权限相关  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建管理员用户</span><br><span class="line">CREATE USER admin WITH PASSWORD &apos;&lt;password&gt;&apos; WITH ALL PRIVILEGES</span><br><span class="line">#或者给一个已经存在的用户管理员权限</span><br><span class="line">GRANT ALL PRIVILEGES TO &quot;todd&quot;</span><br><span class="line">#创建其他用户</span><br><span class="line">CREATE USER &lt;username&gt; WITH PASSWORD &apos;&lt;password&gt;&apos;</span><br><span class="line">#给已经存在的用户授权</span><br><span class="line">GRANT READ ON &quot;db_name&quot; TO &quot;todd&quot;</span><br><span class="line">#撤回权限</span><br><span class="line">REVOKE [READ,WRITE,ALL] ON &lt;database_name&gt; FROM &lt;username&gt;</span><br><span class="line">#查看用户的数据库权限 </span><br><span class="line">SHOW GRANTS FOR &lt;user_name&gt;</span><br><span class="line"></span><br><span class="line">#通用一些操作</span><br><span class="line">##重置用户密码  </span><br><span class="line">SET PASSWORD FOR &lt;username&gt; = &apos;&lt;password&gt;&apos;</span><br><span class="line">#删除用户 </span><br><span class="line">DROP USER &lt;username&gt;</span><br><span class="line">#查看用户</span><br><span class="line">SHOW USERS</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>基于snmp的网络设备的监控.md</title>
    <url>/2019/12/07/yuque/%E5%9F%BA%E4%BA%8Esnmp%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%9A%84%E7%9B%91%E6%8E%A7.md/</url>
    <content><![CDATA[<p><a name="61a3ec66"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>公司当前环境下有基于prometheus的监控体系，覆盖了所有的服务器和虚拟机，但是还没有包含网络设备，例如交换机或者防火墙，因此，需要补充网络设备监控部分</p>
<p><a name="92bec8d9"></a></p>
<h2 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h2><p>prometheus： 监控系统，负责指标的收取和一些告警规则的定义<br>snmp-exporter: 用于通过snmp协议暴露交换机的相关指标<br>SNMP Exporter Config Generator： 此配置生成器使用NetSNMP解析MIB，并使用它们为snmp_exporter生成配置–帮助生成snmp的配置文件<br>MIB和OID： MIB是管理信息库的缩写，它是用于管理通信网络中的实体的数据库。数据库是分层的（树形结构），并且每个条目都通过对象标识符（OID）进行寻址<br>snmp协议： SNMP 是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议</p>
<p><a name="a9f94dcd"></a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p><a name="e8030dd8"></a></p>
<h3 id="网络设备使能snmp-agent"><a href="#网络设备使能snmp-agent" class="headerlink" title="网络设备使能snmp agent"></a>网络设备使能snmp agent</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">system-view</span><br><span class="line">[Sysname] snmp-agent sys-info version v3 v2c</span><br><span class="line">//为了安全，最好只设置只读</span><br><span class="line">[Sysname] snmp-agent community <span class="built_in">read</span> xxxx</span><br><span class="line"><span class="comment">## 测试</span></span><br><span class="line">yum -y install net-snmp-utils  </span><br><span class="line">snmpwalk -v 2c（snmp的版本） -c xxxx(前面snmp-agent设置的密码) 10.10.1.1（交换机管理ip） .1.3.6.1.2.1.25.2.2（mib信息，需要查对应的厂家的mib信息库）  <span class="comment">#取得系统总内存  </span></span><br><span class="line"><span class="comment">#如果能获取到返回信息，则snmp已经可以正常工作</span></span><br></pre></td></tr></table></figure>
<p><a name="557be2e2"></a></p>
<h3 id="使用snmp-exporter抓取snmp-agent的信息"><a href="#使用snmp-exporter抓取snmp-agent的信息" class="headerlink" title="使用snmp-exporter抓取snmp-agent的信息"></a>使用snmp-exporter抓取snmp-agent的信息</h3><p>snmp-exporter：<a href="https://github.com/prometheus/snmp_exporter" target="_blank" rel="noopener">https://github.com/prometheus/snmp_exporter</a><br>使用snmp-exporter的关键是配置snmp-exporter的配置文件，默认有一个配置文件，但是里面涉及的信息基本都是国外交换机的配置，不能直接使用</p>
<p><a name="snmp.yml"></a></p>
<h4 id="snmp-yml"><a href="#snmp-yml" class="headerlink" title="snmp.yml"></a>snmp.yml</h4><p>典型的一个配置如下（部分）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># WARNING: This file was auto-generated using snmp_exporter generator, manual changes will be lost.</span></span><br><span class="line"><span class="attr">apcups:</span></span><br><span class="line">  <span class="attr">walk:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.4</span><span class="number">.1</span><span class="number">.318</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.12</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.4</span><span class="number">.1</span><span class="number">.318</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.4</span><span class="number">.1</span><span class="number">.318</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.4</span><span class="number">.1</span><span class="number">.318</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.4</span><span class="number">.1</span><span class="number">.318</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.7</span><span class="number">.2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.4</span><span class="number">.1</span><span class="number">.318</span><span class="number">.1</span><span class="number">.1</span><span class="number">.10</span><span class="number">.2</span><span class="number">.3</span><span class="number">.2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.4</span><span class="number">.1</span><span class="number">.318</span><span class="number">.1</span><span class="number">.1</span><span class="number">.26</span><span class="number">.8</span><span class="number">.3</span></span><br><span class="line">  <span class="attr">get:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.1</span><span class="number">.3</span><span class="number">.0</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.4</span><span class="number">.1</span><span class="number">.318</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.8</span><span class="number">.1</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sysUpTime</span></span><br><span class="line">    <span class="attr">oid:</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.1</span><span class="number">.3</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">The</span> <span class="string">time</span> <span class="string">(in</span> <span class="string">hundredths</span> <span class="string">of</span> <span class="string">a</span> <span class="string">second)</span> <span class="string">since</span> <span class="string">the</span> <span class="string">network</span> <span class="string">management</span> <span class="string">portion</span></span><br><span class="line">      <span class="string">of</span> <span class="string">the</span> <span class="string">system</span> <span class="string">was</span> <span class="string">last</span> <span class="string">re-initialized.</span> <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.1</span><span class="number">.3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ifNumber</span></span><br><span class="line">    <span class="attr">oid:</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">The</span> <span class="string">number</span> <span class="string">of</span> <span class="string">network</span> <span class="string">interfaces</span> <span class="string">(regardless</span> <span class="string">of</span> <span class="string">their</span> <span class="string">current</span> <span class="string">state)</span> <span class="string">present</span></span><br><span class="line">      <span class="string">on</span> <span class="string">this</span> <span class="string">system.</span> <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ifIndex</span></span><br><span class="line">    <span class="attr">oid:</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">    <span class="attr">help:</span> <span class="string">A</span> <span class="string">unique</span> <span class="string">value,</span> <span class="string">greater</span> <span class="string">than</span> <span class="string">zero,</span> <span class="string">for</span> <span class="string">each</span> <span class="string">interface</span> <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">indexes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">labelname:</span> <span class="string">ifIndex</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">gauge</span></span><br><span class="line">      <span class="string">........</span></span><br><span class="line">      <span class="string">........</span></span><br><span class="line">      <span class="string">........</span></span><br><span class="line">      <span class="comment">#默认的完整配置高达17000行~</span></span><br></pre></td></tr></table></figure>
<p>这样的配置文件，显然不是我们需要手动配置的，因为文件的第一行已经声明了，这个配置文件是用工具生成的；如果不用工具，我们需要从mib中找到对应的oid信息在这里配置。。。太难了<br>，还有没有更简单的方法？</p>
<p><a name="45ae74cb"></a></p>
<h4 id="snmp-exporter-generator"><a href="#snmp-exporter-generator" class="headerlink" title="snmp-exporter generator"></a>snmp-exporter generator</h4><p>Prometheus team特此准备了snmp-exporter generator一个专门用于生成snmp-exporter的工具<br>Generator: <a href="https://github.com/prometheus/snmp_exporter/tree/master/generator" target="_blank" rel="noopener">Generator</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line"> sudo yum install gcc gcc-g++ make net-snmp net-snmp-utils net-snmp-libs net-snmp-devel # RHEL-based distros</span><br><span class="line">go get github.com/prometheus/snmp_exporter/generator</span><br><span class="line">cd $&#123;GOPATH-$HOME/go&#125;/src/github.com/prometheus/snmp_exporter/generator</span><br><span class="line">go build</span><br><span class="line">make mibs</span><br><span class="line">使用</span><br><span class="line">export MIBDIRS=mibs</span><br><span class="line">./generator generate</span><br><span class="line">它会根据generator.yml的配置来生成配置文件，generator.yml的配置就简单多了</span><br></pre></td></tr></table></figure>
<p><a name="generator.yml"></a></p>
<h5 id="generator-yml"><a href="#generator-yml" class="headerlink" title="generator.yml"></a>generator.yml</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">modules:</span></span><br><span class="line">  <span class="attr">huawei:</span></span><br><span class="line">    <span class="attr">walk:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hwDev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.1</span><span class="number">.3</span>   <span class="comment">#sysUpTime</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.31</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.10</span> <span class="comment">#ifHCOutOctets</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.14</span> <span class="comment">#ifInErrors</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.20</span> <span class="comment">#ifOutErrors</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.31</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.6</span> <span class="comment">#ifHCInOctets</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.21</span> <span class="comment">#ifOutQLen</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.13</span> <span class="comment">#ifInDiscards</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.19</span> <span class="comment">#ifOutDiscards</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.7</span> <span class="comment">#ifAdminStatus</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.8</span> <span class="comment">#ifOperStatus</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span> <span class="comment">#ifDescr</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.31</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span> <span class="comment">#ifName</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.5</span> <span class="comment">#ifSpeed</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.31</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.15</span> <span class="comment">#ifHighSpeed</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.31</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.18</span> <span class="comment">#ifAlias</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.2</span><span class="number">.2</span><span class="number">.1</span><span class="number">.3</span> <span class="comment">#ifType</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.31</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.11</span> <span class="comment">#ifHCOutUcastPkts</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.31</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.7</span> <span class="comment">#ifHCInUcastPkts</span></span><br><span class="line">    <span class="comment">##定义数据中需要的额外的labels</span></span><br><span class="line">    <span class="attr">lookups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_indexes:</span> <span class="string">[ifIndex]</span></span><br><span class="line">        <span class="attr">lookup:</span> <span class="string">ifAlias</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_indexes:</span> <span class="string">[ifIndex]</span></span><br><span class="line">        <span class="attr">lookup:</span> <span class="string">ifDescr</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_indexes:</span> <span class="string">[ifIndex]</span></span><br><span class="line">        <span class="comment"># Use OID to avoid conflict with Netscaler NS-ROOT-MIB.</span></span><br><span class="line">        <span class="attr">lookup:</span> <span class="number">1.3</span><span class="number">.6</span><span class="number">.1</span><span class="number">.2</span><span class="number">.1</span><span class="number">.31</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span><span class="number">.1</span> <span class="comment"># ifName</span></span><br><span class="line">    <span class="attr">overrides:</span></span><br><span class="line">      <span class="attr">ifAlias:</span></span><br><span class="line">        <span class="attr">ignore:</span> <span class="literal">true</span> <span class="comment"># Lookup metric</span></span><br><span class="line">      <span class="attr">ifDescr:</span></span><br><span class="line">        <span class="attr">ignore:</span> <span class="literal">true</span> <span class="comment"># Lookup metric</span></span><br><span class="line">      <span class="attr">ifName:</span></span><br><span class="line">        <span class="attr">ignore:</span> <span class="literal">true</span> <span class="comment"># Lookup metric</span></span><br><span class="line">      <span class="attr">ifType:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">EnumAsInfo</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">auth:</span></span><br><span class="line">      <span class="attr">community:</span> <span class="string">xxxx(snmp-agent设置的密码)</span></span><br></pre></td></tr></table></figure>
<p>这里的oid信息就可以根据具体的厂商去查找了，例如华为： <a href="https://support.huawei.com/enterprise/zh/doc/EDOC1000178142/948603b1" target="_blank" rel="noopener">https://support.huawei.com/enterprise/zh/doc/EDOC1000178142/948603b1</a><br>填写在配置文件的walk区域<br>定义lookups和overrides给抓取的数据添加一些我们需要的labels<br>定义auth和version信息，这个是是我们交换机前面已经设置好的<br>这里只定义了我们需要walk的oid信息，但是实体信息是在mib里面的，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hwDev 来自 HUAWEI-MIB;</span><br><span class="line">hwFrameIndex, hwSlotIndex 来自 HUAWEI-DEVICE-MIB;</span><br><span class="line">OBJECT-GROUP, MODULE-COMPLIANCE 来自 SNMPv2-CONF;</span><br><span class="line">Gauge, OBJECT-TYPE, MODULE-IDENTITY 来自 SNMPv2-SMI.</span><br><span class="line">等等</span><br></pre></td></tr></table></figure>
<p>那么mib在哪里有呢，这里提供了大量的mib库，<a href="https://github.com/librenms/librenms/blob/master/mibs" target="_blank" rel="noopener">https://github.com/librenms/librenms/blob/master/mibs</a><br>在生成配置文件的时候，会尝试读取本地的mib库，$HOME/.snmp/mibs，因此我们把所需要的mib信息放在此处： $HOME/.snmp/mibs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@opsmanager ~]# ll $HOME/.snmp/mibs</span><br><span class="line">total 636</span><br><span class="line">-rw-r--r-- 1 root root   7440 Nov 13 10:14 HUAWEI-CPU-MIB</span><br><span class="line">-rw-r--r-- 1 root root 351413 Nov 13 10:14 HUAWEI-DEVICE-MIB</span><br><span class="line">-rw-r--r-- 1 root root   9967 Nov 13 10:12 HUAWEI-MEMORY-MIB</span><br><span class="line">-rw-r--r-- 1 root root 146824 Nov 13 10:12 HUAWEI-MIB</span><br><span class="line">-rw-r--r-- 1 root root  71691 Nov 13 21:58 IF-MIB</span><br><span class="line">-rw-r--r-- 1 root root   8263 Nov 13 10:16 SNMPv2-CONF</span><br><span class="line">-rw-r--r-- 1 root root  29305 Nov 13 10:16 SNMPv2-MIB</span><br><span class="line">-rw-r--r-- 1 root root   8924 Nov 13 10:16 SNMPv2-SMI</span><br></pre></td></tr></table></figure>
<p>配置文件准备完毕，直接生成配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@opsmanager snmp_exporter]# ./generator generate</span><br><span class="line">INFO[0000] Loading MIBs from $HOME/.snmp/mibs:/usr/share/snmp/mibs  source=&quot;net_snmp.go:141&quot;</span><br><span class="line">WARN[0000] NetSNMP reported 7 parse errors               source=&quot;main.go:103&quot;</span><br><span class="line">INFO[0000] Generating config for module huawei           source=&quot;main.go:49&quot;</span><br><span class="line">INFO[0000] Generated 310 metrics for module huawei       source=&quot;main.go:60&quot;</span><br><span class="line">INFO[0000] Config written to /opt/snmp_exporter/snmp.yml  source=&quot;main.go:85&quot;</span><br></pre></td></tr></table></figure>
<p>我们可以直接使用生成的配置文件启动，snmp-exporter<br><code>nohup snmp-exporter &amp;</code></p>
<p>验证页面<br><a href="http://xx.xx.xx.xx:9116" target="_blank" rel="noopener">http://xx.xx.xx.xx:9116</a><br>输入generator配置里面的模块名称和想要抓取的目标网络设备的ip，即可查看抓取的所有指标</p>
<p><a name="9a53e8f9"></a></p>
<h3 id="将指标接入prometheus"><a href="#将指标接入prometheus" class="headerlink" title="将指标接入prometheus"></a>将指标接入prometheus</h3><p>直接使用默认配置即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'snmp'</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span>  <span class="comment"># SNMP device.</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">xx.xx.xx.xx</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">.....</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">/snmp</span></span><br><span class="line">    <span class="attr">params:</span></span><br><span class="line">      <span class="attr">module:</span> <span class="string">[if_mib]</span></span><br><span class="line">    <span class="attr">relabel_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__address__]</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">__param_target</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">source_labels:</span> <span class="string">[__param_target]</span></span><br><span class="line">        <span class="attr">target_label:</span> <span class="string">instance</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">target_label:</span> <span class="string">__address__</span></span><br><span class="line">        <span class="attr">replacement:</span> <span class="string">xx.xx.xx.xx:9116</span>  <span class="comment"># The SNMP exporter's real hostname:port.</span></span><br></pre></td></tr></table></figure>
<p>重新加载prometheus的配置<br><code>curl -X POST http://xx.xxx.xx.xx:9090/-/reload</code></p>
<p>接下来就是基于这些指标的绘图和告警设置了</p>
<p><a name="sYVJr"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://devopstarter.info/snmp-exporter-generator-tutorial/" target="_blank" rel="noopener">http://devopstarter.info/snmp-exporter-generator-tutorial/</a>   <br><a href="https://github.com/prometheus/snmp_exporter" target="_blank" rel="noopener">https://github.com/prometheus/snmp_exporter</a>   <br><a href="https://github.com/prometheus/snmp_exporter/tree/master/generator" target="_blank" rel="noopener">https://github.com/prometheus/snmp_exporter/tree/master/generator</a>  <br><a href="https://github.com/librenms/librenms/tree/master/mibs" target="_blank" rel="noopener">https://github.com/librenms/librenms/tree/master/mibs</a>  <br><a href="https://www.cnblogs.com/guoxiangyue/p/11778217.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoxiangyue/p/11778217.html</a>  <br><a href="https://www.cnblogs.com/--smile/p/11086770.html" target="_blank" rel="noopener">https://www.cnblogs.com/–smile/p/11086770.html</a>  <br><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1000141473/40dfdfef" target="_blank" rel="noopener">https://support.huawei.com/enterprise/zh/doc/EDOC1000141473/40dfdfef</a>  <br><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1000178142/948603b1" target="_blank" rel="noopener">https://support.huawei.com/enterprise/zh/doc/EDOC1000178142/948603b1</a>  </p>
]]></content>
  </entry>
  <entry>
    <title>ELK相关的那些东东</title>
    <url>/2019/11/30/yuque/ELK%E7%9B%B8%E5%85%B3%E7%9A%84%E9%82%A3%E4%BA%9B%E4%B8%9C%E4%B8%9C/</url>
    <content><![CDATA[<p><a name="EABbF"></a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>额，网上文章好多，后面在补充<br><a name="LjTWF"></a></p>
<h2 id="使用相关"><a href="#使用相关" class="headerlink" title="使用相关"></a>使用相关</h2><p><a name="i2L0J"></a></p>
<h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><p>模糊查询日志  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#模糊查询： </span></span><br><span class="line">log_message:boot*</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1575085668820-e618e7f6-8633-48a0-af27-72a1bbff8a3a.png#align=left&amp;display=inline&amp;height=90&amp;name=image.png&amp;originHeight=90&amp;originWidth=855&amp;size=10466&amp;status=done&amp;style=none&amp;width=855" alt="image.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#模糊查询： </span></span><br><span class="line">log_message:<span class="string">"bootstrap false"</span>~100</span><br><span class="line"><span class="comment">#表示两个单词之间最大匹配100个字符</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1575085767910-72e317a4-a12a-4e6e-b888-41f935638d7e.png#align=left&amp;display=inline&amp;height=75&amp;name=image.png&amp;originHeight=75&amp;originWidth=551&amp;size=6460&amp;status=done&amp;style=none&amp;width=551" alt="image.png"></p>
<p>开发工具的使用  <br>console  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取ES基本信息，和之间访问 http://ES_IP:9200效果一样</span></span><br><span class="line">GET /</span><br><span class="line"><span class="comment"># 根据索引查询</span></span><br><span class="line">GET INDEX_NAME.*/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"range"</span>: &#123;</span><br><span class="line">            <span class="string">"@timestamp"</span>: &#123;</span><br><span class="line">              <span class="string">"gte"</span>: <span class="string">"now-10h"</span>,</span><br><span class="line">              <span class="string">"lte"</span>: <span class="string">"now"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match_phrase"</span>: &#123;</span><br><span class="line">		  </span><br><span class="line">            <span class="string">"log_level"</span>: <span class="string">"WARN"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="string">"tags"</span>: <span class="string">"DataWarehouse"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"must_not"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="string">"log_message"</span>: <span class="string">"containermanager.ContainerManagerImpl (ContainerManagerImpl.java:handle(1654))"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="string">"log_message"</span>: <span class="string">"caught end of stream exception EndOfStreamException"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GROK DEBUG<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1575086606988-a33c7edb-0bf6-4b5a-8e74-42d9c08a5aeb.png#align=left&amp;display=inline&amp;height=601&amp;name=image.png&amp;originHeight=601&amp;originWidth=1208&amp;size=66238&amp;status=done&amp;style=none&amp;width=1208" alt="image.png"><br>使用自定义表达式可以更精确的匹配日志信息  <br>内置的表达式: <a href="https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns" target="_blank" rel="noopener">https://github.com/logstash-plugins/logstash-patterns-core/tree/master/patterns</a>  </p>
<p><code>.*$</code>  匹配到最后</p>
]]></content>
  </entry>
  <entry>
    <title>NGINX禁止使用IP访问，防止恶意域名解析</title>
    <url>/2019/10/15/yuque/NGINX%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8IP%E8%AE%BF%E9%97%AE%EF%BC%8C%E9%98%B2%E6%AD%A2%E6%81%B6%E6%84%8F%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><a name="q1jtm"></a></p>
<h2 id="什么是恶意域名解析"><a href="#什么是恶意域名解析" class="headerlink" title="什么是恶意域名解析"></a>什么是恶意域名解析</h2><p>外部未知的域名持有者，将域名解析到非其所持有的服务器<strong>公网IP</strong>上，间接或直接造成损害他人利益的行为。<br><a name="psZUL"></a></p>
<h2 id="暗箭伤人"><a href="#暗箭伤人" class="headerlink" title="暗箭伤人"></a>暗箭伤人</h2><p>域名的恶意解析，可以用于借刀杀人。  <br><br>这个手法很骚，轻则可以将对手的SEO排名拉低，重则可以让工信部封杀其站点。  <br><strong>具体实现条件如下：  </strong></p>
<ul>
<li>未备案的域名或已被接入工信部黑名单的域名</li>
<li>获取要攻击的站点，其源服务器使用的<strong>公网IP</strong></li>
<li>确认要攻击的网站80端口和443端口可以直接用IP直接访问</li>
<li>将黑域名解析到该公网IP</li>
</ul>
<p><strong>危害如下：  </strong></p>
<ul>
<li>不同域名解析到同个站点，真身域名权重被降低，SEO排名被假域名挤占  </li>
<li>非法域名解析，导致源服务器被工信部封杀，网站停止服务<br><a name="2DUzV"></a><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><blockquote>
<p>将无效域名的HTTP请求，全部拒绝响应</p>
</blockquote>
</li>
</ul>
<p>新加一个server段如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">      server &#123;</span><br><span class="line">        listen    443 default_server;</span><br><span class="line">        listen     80 default_server;</span><br><span class="line">        #筛选无效域名</span><br><span class="line">        server_name  _;</span><br><span class="line">        #直接返回错误码的方式</span><br><span class="line">        return 404;</span><br><span class="line">        #rewrite 的方式(比较友好)</span><br><span class="line">        #rewrite ^(.*)$ https://xxx.com/40x.html permanent;</span><br><span class="line">        #日志可选，可以看看哪些非法访问</span><br><span class="line">        #access_log off;</span><br><span class="line">        ssl_certificate "/usr/local/openresty/nginx/ssl/demofullchain.cer";</span><br><span class="line">        ssl_certificate_key "/usr/local/openresty/nginx/ssl/demo.dingtalk.pub.key";</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>k8s网络小探</title>
    <url>/2019/10/10/yuque/k8s%E7%BD%91%E7%BB%9C%E5%B0%8F%E6%8E%A2/</url>
    <content><![CDATA[<p><a name="urHMZ"></a></p>
<h2 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h2><p>在说k8s的网络之前，先熟悉下容器的网络模式。</p>
<ul>
<li>docker会在宿主机启动一张网卡 docker0</li>
<li>容器通过Veth Pair 连接容器和docker0，Veth Pair相当于网线</li>
<li>docker0 在容器通信的过程中相当于二层交换机</li>
<li>容器会有默认路由指向docker0</li>
<li>当一个容器试图连接到另外一个宿主机时，首先经过 docker0 网桥出现在宿主机上。然后根据宿主机路由规则路由<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用以下命令查看网桥的连接情况</span></span><br><span class="line">[root@rbtnode1 ~]# brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br-5bc39396abe2         8000.024219350061       no              veth1a289de</span><br><span class="line">                                                        veth3504d23</span><br><span class="line">docker0         8000.0242d50f88b5       no              veth210c0a2</span><br><span class="line">...</span><br><span class="line">[root@rbtnode1 ~]# ip ad | grep veth</span><br><span class="line">16: vethwe-datapath@vethwe-bridge: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1376 qdisc noqueue master datapath state UP group default </span><br><span class="line">17: vethwe-bridge@vethwe-datapath: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1376 qdisc noqueue master weave state UP group default </span><br><span class="line">2631: veth210c0a2@if2630: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">2682: veth3504d23@if2681: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br-5bc39396abe2 state UP group default </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#这里可以看到我们宿主机存在一个虚拟网卡 veth3504d23 ，他一端连接的是docker0，另一端则连接的是容器的eth0</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#其他的容器在创建的时候也会发生同样的事</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#相当于启动容器后，会有一“网线”，连接docker0和容器，由于都连接同一个交换机，默认情况下，各个容器间可以直接互通</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>容器的通信示意图（源自张磊）：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1570674419563-e193a874-8465-43fa-9f7e-91e80d072e2c.png#align=left&amp;display=inline&amp;height=995&amp;originHeight=995&amp;originWidth=1715&amp;size=0&amp;status=done&amp;width=1715" alt><br><a name="VFzuc"></a></p>
<h2 id="k8s网络的发展"><a href="#k8s网络的发展" class="headerlink" title="k8s网络的发展"></a>k8s网络的发展</h2><p>在docker的默认配置下，容器的网络没法处理跨主机网络的互相通信。为了解决跨主机通信的问题，社区出现了一些方案<br><a name="yjZxl"></a></p>
<h3 id="flannel-UDP-模式"><a href="#flannel-UDP-模式" class="headerlink" title="flannel UDP  模式"></a>flannel UDP  模式</h3><p>而 UDP 模式，是 Flannel 项目最早支持的一种方式，也是性能最差的一种模式，如今已被弃用，但是对我们理解集群的网络还是有帮助的 </p>
<p>该模式的主要通信过程如下</p>
<ol>
<li>容器A需要发送一个数据包到B(用户态)</li>
<li>首先还是会到docker0网口（<strong>用户态-&gt;内核态</strong>）</li>
<li>flannel在运行的时候会在宿主机创建一系列的路由规则(xx.xx.xx.xx/16 dev  flannel0，前提是docker0的网桥网段范围由flannel控制，dockerd启动的时候添加参数即可，FLANNEL_SUBNET=100.96.1.1/24 dockerd –bip=$FLANNEL_SUBNET ）</li>
<li>A需要访问的网段，会走宿主机的路由，他的下一跳是flannel0（内核态）</li>
<li>flannel0这里会把数据包交给应用程序 flanneld:8125 （<strong>内核态-&gt;用户态</strong>）</li>
<li>flanneld 进行 UDP 封包之后重新进入内核态，将udp的包通过宿主机的发出去（<strong>用户态-&gt;内核态</strong>）</li>
</ol>
<p>UDP模式示意图（源自张磊）：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1570806444983-6d3641f7-0366-4802-b438-8b1d33018b2f.png#align=left&amp;display=inline&amp;height=878&amp;originHeight=878&amp;originWidth=1857&amp;size=0&amp;status=done&amp;width=1857" alt><br>UDP模式内核、用户态示意图（源自张磊）：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1570806367579-5461c6fa-f46a-48cb-b170-31cbc73e9c6d.png#align=left&amp;display=inline&amp;height=593&amp;originHeight=593&amp;originWidth=890&amp;size=0&amp;status=done&amp;width=890" alt><br>可以看出该模式仅在ip包发出的过程中，就需要经过三次用户态与内核态之间的数据拷贝，这个代价是比较高的，所以被弃用<br><a name="ScAHi"></a></p>
<h3 id="flannel-VXLAN-模式"><a href="#flannel-VXLAN-模式" class="headerlink" title="flannel VXLAN 模式"></a>flannel VXLAN 模式</h3><p>Virtual Extensible LAN（虚拟可扩展局域网），VXLAN可以完全在内核态完成上述的封装和解封过程，大大提升了性能。<br>VXLAN旨在在前的3层网络之上“覆盖”一层虚拟的，由vxlan内核模块负责的二层网络，以支持弹性计算结构；使得连接在这个VXLAN二层网络上的主机（虚拟机或者容器都行），可以像在同一个局域网（LAN）内自由连通,<br>即使这些主机在不同的物理机上。<br>VXLAN Tunnel End Point（虚拟隧道端点），VXLAN在宿主机建立的虚拟网络设备，作用是对二层数据帧（Ethernet frame）数据进行封装和解封  <br>为了封装以太网帧，VTEP添加了许多字段，包括以下字段：</p>
<ul>
<li>外部媒体访问控制（MAC）目标地址（隧道端点VTEP的MAC地址）<br></li>
<li>外部MAC源地址（隧道源VTEP的MAC地址）<br></li>
<li>外部IP目标地址（隧道端点VTEP的IP地址）<br></li>
<li>外部IP源地址（隧道源VTEP的IP地址）<br></li>
<li>外部UDP标头<br></li>
<li>VXLAN标头包含一个24位字段（称为<em>VXLAN网络标识符（VNI））</em>，用于唯一标识VXLAN。VNI与VLAN ID相似，但是具有24位允许您创建比VLAN多得多的VXLAN。<br></li>
</ul>
<p>在这种模式下，数据包的流转依然需要经过flanneld，但是处理机制不同了   containers-&gt;docker0-&gt;flannel.1-&gt;eth0 <br>基于VTEP设备进行通信的示意图：  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1570807301813-cf2eabf1-2e85-4446-a39c-05125907e7e9.png#align=left&amp;display=inline&amp;height=394&amp;originHeight=933&amp;originWidth=1767&amp;size=0&amp;status=done&amp;width=746" alt>  1. 图中每台宿主机上名叫 flannel.1 的设备，就是 VXLAN 所需的 VTEP 设备，它既有 IP 地址，也有 MAC 地址。</p>
<ol start="2">
<li>现在，我们的 container-1 的 IP 地址是 10.1.15.2，要访问的 container-2 的 IP 地址是 10.1.16.3。 </li>
<li>flannel在运行的时候会在宿主机创建一系列的路由规则(xx.xx.xx.xx/24 dev  flannel.1）</li>
<li>为了能够将“原始 IP 包”封装并且发送到正确的宿主机，VXLAN 就需要找到这条“隧道”的出口，即：目的宿主机的 VTEP 设备-&gt;给这个原始数据包加上目的MAC（二层封装）</li>
<li>那么这个目的MAC的地址是什么呢，前面说道VTEP设备有ip和MAC，那么有ip想知道MAC就是ARP实现的东西了，在VTEP创建好后，会在自己的ARP表中记录，ip neigh show dev flannel.1 可以看到</li>
</ol>
<p>初步封包如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1570808262275-39efd876-4e80-40a8-9ddb-1a72bac3f413.png#align=left&amp;display=inline&amp;height=179&amp;originHeight=179&amp;originWidth=799&amp;size=0&amp;status=done&amp;width=799" alt></p>
<ol start="6">
<li>但是，上面提到的这些 VTEP 设备的 MAC 地址，对于宿主机网络来说并没有什么实际意义。所以上面封装出来的这个数据帧，并不能在我们的宿主机二层网络里传输。为了方便叙述，我们把它称为“内部数据帧”（Inner Ethernet Frame）。</li>
<li>所以接下来，Linux 内核还需要再把“内部数据帧”进一步封装成为宿主机网络里的一个普通的数据帧，好让它“载着”“内部数据帧”，通过宿主机的 eth0 网卡进行传输。</li>
<li>我们把这次要封装出来的、宿主机对应的数据帧称为“外部数据帧”（Outer Ethernet Frame）。</li>
<li>Linux 内核会在“内部数据帧”前面，加上一个特殊的 VXLAN 头，用来表示这个实际上是一个 VXLAN 要使用的数据帧。</li>
<li>而这个 VXLAN 头里有一个重要的标志叫作VNI,，它是 VTEP 设备识别某个数据帧是不是应该归自己处理的重要标识。而在 Flannel 中，VNI 的默认值是 1，这也是为何，宿主机上的 VTEP 设备都叫作 flannel.1 的原因，这里的“1”，其实就是 VNI 的值。</li>
<li>然后，Linux 内核会把这个数据帧封装进一个 UDP 包里发出去。</li>
<li>不过，一个 flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对应的宿主机地址是什么。</li>
<li>在这种场景下，flannel.1 设备实际上要扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。而在 Linux 内核里面，“网桥”设备进行转发的依据，来自于一个叫作 FDB（Forwarding Database）的转发数据库。</li>
<li>这个 flannel.1“网桥”对应的 FDB 信息，也是 flanneld 进程负责维护的。它的内容可以通过 bridge fdb 命令查看到，如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在 Node 1 上，使用“目的 VTEP 设备”的 MAC 地址进行查询</span><br><span class="line">$ bridge fdb show flannel.1 | grep 5e:f8:4f:00:e3:37</span><br><span class="line">5e:f8:4f:00:e3:37 dev flannel.1 dst 10.168.0.3 self permanent</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样udp的目的地就有了</p>
<ol start="15">
<li>UDP 包是一个四层数据包，所以 Linux 内核会在它前面加上一个 IP 头，即原理图中的 Outer IP Header，组成一个 IP 包。并且，在这个 IP 头里，会填上前面通过 FDB 查询出来的目的主机的 IP 地址，即 Node 2 的 IP 地址 10.168.0.3。</li>
<li>最后，Linux 内核再在这个 IP 包前面加上二层数据帧头，即原理图中的 Outer Ethernet Header，并把 Node 2 的 MAC 地址填进去。这个 MAC 地址本身，是 Node 1 的 ARP 表要学习的内容，无需 Flannel 维护。这时候，我们封装出来的“外部数据帧”的格式，如下所示（张磊图）：<img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1570808886179-56eb4e2f-a728-4a83-a0fc-d39a2199ae1d.png#align=left&amp;display=inline&amp;height=192&amp;originHeight=192&amp;originWidth=1864&amp;size=0&amp;status=done&amp;width=1864" alt></li>
</ol>
<p>另外一个示意图：<img src="https://cdn.nlark.com/yuque/0/2019/gif/148941/1570809040224-e4e091c5-e8e4-4c84-b660-add56b3fa671.gif#align=left&amp;display=inline&amp;height=228&amp;originHeight=228&amp;originWidth=744&amp;size=0&amp;status=done&amp;width=744" alt></p>
<ol start="17">
<li>接下来，Node 1 上的 flannel.1 设备就可以把这个数据帧从 Node 1 的 eth0 网卡发出去。显然，这个帧会经过宿主机网络来到 Node 2 的 eth0 网卡。这时候，Node 2 的内核网络栈会发现这个数据帧里有 VXLAN Header，并且 VNI=1。所以 Linux 内核会对它进行拆包，拿到里面的内部数据帧，然后根据 VNI 的值，把它交给 Node 2 上的 flannel.1 设备。而 flannel.1 设备则会进一步拆包，取出“原始 IP 包”。接下来就回到了我在前面提到的单机容器网络的处理流程。最终，IP 包就进入到了 container-2 容器的 Network Namespace 里。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>嗯~每天少玩一会手机</title>
    <url>/2019/10/08/yuque/%E5%97%AF~%E6%AF%8F%E5%A4%A9%E5%B0%91%E7%8E%A9%E4%B8%80%E4%BC%9A%E6%89%8B%E6%9C%BA/</url>
    <content><![CDATA[<p><a name="9q0hj"></a></p>
<h2 id="大概每天更新一下吧"><a href="#大概每天更新一下吧" class="headerlink" title="大概每天更新一下吧"></a>大概每天更新一下吧</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/148941/1570462563940-15dc33fc-3280-401e-b1f2-f5a7943af648.jpeg?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_c25vb3B5,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#align=left&amp;display=inline&amp;height=1280&amp;originHeight=1280&amp;originWidth=640&amp;status=done&amp;width=640" alt><br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1570548776051-0c37f9d1-3202-46a8-923e-60715f018ad3.png#align=left&amp;display=inline&amp;height=1280&amp;name=image.png&amp;originHeight=1280&amp;originWidth=640&amp;size=163277&amp;status=done&amp;width=640" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1570663443476-ec515b5f-3562-432e-b27a-e4d66bdb272c.png#align=left&amp;display=inline&amp;height=2160&amp;name=image.png&amp;originHeight=2160&amp;originWidth=1080&amp;size=231063&amp;status=done&amp;width=1080" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1570809498493-88bbbffd-eeda-48f3-bae2-86e613162f7b.png#align=left&amp;display=inline&amp;height=1280&amp;name=image.png&amp;originHeight=1280&amp;originWidth=640&amp;size=157772&amp;status=done&amp;width=640" alt="image.png"></p>
<p>我觉得，每天手机亮屏的时间不超过一个小时，才算是正常的呀~</p>
]]></content>
  </entry>
  <entry>
    <title>关于自己的作息时间的优化的一些想法</title>
    <url>/2019/10/07/yuque/%E5%85%B3%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BD%9C%E6%81%AF%E6%97%B6%E9%97%B4%E7%9A%84%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<p><a name="S6mBS"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当前的作息时间，总的来说，这样的，早上没什么事儿的话，基本是8点40左右起床，然后中午工作到12点的样子，在，12点到1点30午休，6点的样子下班。存在的问题如下：</p>
<ol>
<li>起的太晚，几乎没有见过这里的的太阳升起</li>
<li>中午有空闲时间被浪费，吃完饭12:30的样子，但是实际午休实际是13:00到13:30，中间30分钟一般在玩手机</li>
<li>下班后时间没有安排，浪费了，当前基本下班后的时间是用于游戏or游戏or很少的运动。一直到晚上23：00的样子，一般晚上的睡觉时间是24:00了<br><a name="hyEkO"></a><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2>为什么突然有所感慨呢，国庆的时候，去了远方，心爱女子（自己心目中的女友，也是人生中最重要的另一半）的一些话，深深的触动人心。很有实际的一些话，怎么说呢，如果一直这样下去的话，我肯定是没法给她想要的生活，没法给她想要的生活，也肯定不是我所想。 所以改变， 从心底想要的改变就这样出现了。<br><a name="eAzx2"></a><h2 id="打算搞事？"><a href="#打算搞事？" class="headerlink" title="打算搞事？"></a>打算搞事？</h2>不搞事儿，那就等死？反正不搞事儿肯定是没结果呢，肯定是继续沉沦呢<br><a name="6wg6z"></a><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>额这里不是文章的末尾，这里的参考只是作息时间的参考，网上找了陆军的作息时间表（我曾经真的很想从军），额，好难找，不知道对不对，但是就借鉴一下吧，至少比我当前的作息时间安排优秀<br><a name="grJCK"></a><h3 id="陆军作息时间表"><a href="#陆军作息时间表" class="headerlink" title="陆军作息时间表"></a>陆军作息时间表</h3><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/148941/1570460361824-7972b92f-cc4b-4a84-a03e-5fc4306b356c.jpeg#align=left&amp;display=inline&amp;height=759&amp;originHeight=759&amp;originWidth=677&amp;size=0&amp;status=done&amp;width=677" alt><br><a name="bdEmC"></a><h3 id="我自己拟定的作息时间表"><a href="#我自己拟定的作息时间表" class="headerlink" title="我自己拟定的作息时间表"></a>我自己拟定的作息时间表</h3></li>
</ol>
<table>
<thead>
<tr>
<th>科目</th>
<th>作息时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>起床哨</td>
<td>6:00</td>
</tr>
<tr>
<td>起床/洗漱</td>
<td>6:00-6:15</td>
</tr>
<tr>
<td>晨练/晨读</td>
<td>6:15-7:30</td>
</tr>
<tr>
<td>学英语</td>
<td>7:30-8:00</td>
</tr>
<tr>
<td>用餐</td>
<td>8:00~8:15</td>
</tr>
<tr>
<td>上班</td>
<td>8:20-11:40</td>
</tr>
<tr>
<td>午餐</td>
<td>11:40-12:30</td>
</tr>
<tr>
<td>梳理上午没整好的</td>
<td>12:30-13:00</td>
</tr>
<tr>
<td>午休</td>
<td>13:00-13:35</td>
</tr>
<tr>
<td>下午工作时间</td>
<td>13:40-18:00</td>
</tr>
<tr>
<td>晚餐</td>
<td>18:00-18:30</td>
</tr>
<tr>
<td>工作总结</td>
<td>18:30-19:00</td>
</tr>
<tr>
<td>学习</td>
<td>19:10-20:00</td>
</tr>
<tr>
<td>活动</td>
<td>20:10-21:00</td>
</tr>
<tr>
<td>学习总结</td>
<td>21:00-22:00</td>
</tr>
<tr>
<td>待定</td>
<td>22:00-23:00</td>
</tr>
<tr>
<td>晚安</td>
<td>24:00-6:00</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>注：</p>
<ul>
<li>20191007 初始方案，有 较多的待定，再后面具体实施的时候优化</li>
<li>20191008  计划开始的第一天，哪个人脑壳坏掉把闹钟订到6点的感觉才睡着呢。。。最终在每隔10分钟的一次闹钟的照顾下，7点多起来了，嗯，看了会儿英语；中午吃饭的时候，看到前辈说作息时间应该有所机动，最开始的理解是每个时间段的安排，留下一定的富余时间，不然很难执行到，确实领会到了，除了上班的时间是执行到位，其他的基本都差别比较大；后面看另外一个前辈说的，应该重要的是做了或者没做，而不是按时做了。所以今天把计划稍微改下，留部分机动的时间。目前看来23：00就睡觉有点扯犊子了</li>
</ul>
<p><a name="Qunre"></a></p>
<h3 id="其他的小改变呢？"><a href="#其他的小改变呢？" class="headerlink" title="其他的小改变呢？"></a>其他的小改变呢？</h3><ol>
<li>每天不要玩那么多的手机了呢，刷刷头条什么的？  内容那么多，多少是对自己实际有用的呢</li>
<li>一步一个脚印，不要急</li>
<li>争取开挂成功，始终提醒自己，“善始者众,善终者寡。”——司马迁《史记·乐毅列传》</li>
<li>减少屏幕使用时间</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/148941/1570462563940-15dc33fc-3280-401e-b1f2-f5a7943af648.jpeg#align=left&amp;display=inline&amp;height=1280&amp;name=Screenshot_2019-10-07-23-34-12-991_com.xiaomi.misettings.jpg&amp;originHeight=1280&amp;originWidth=640&amp;size=45139&amp;status=done&amp;width=640" alt="Screenshot_2019-10-07-23-34-12-991_com.xiaomi.misettings.jpg"></p>
<ol start="5">
<li>一起来见证，在直播一起进步呀<br><a name="L36QT"></a><h2 id="伊人在远方，怎敢有怠慢。"><a href="#伊人在远方，怎敢有怠慢。" class="headerlink" title="伊人在远方，怎敢有怠慢。"></a>伊人在远方，怎敢有怠慢。</h2></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>aria2c 不限速下载服务配置 RPC</title>
    <url>/2019/09/16/yuque/aria2c%20%E4%B8%8D%E9%99%90%E9%80%9F%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%20RPC/</url>
    <content><![CDATA[<p><a name="y7Qnj"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>aria2是一个轻量级的多协议和多源，跨平台下载实用程序，在命令行中运行。它支持HTTP / HTTPS，FTP，SFTP，BitTorrent和Metalink。<a href="https://aria2.github.io/" target="_blank" rel="noopener">https://aria2.github.io/</a><br><a name="9OTU1"></a></p>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><p><a name="0WNzQ"></a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在epel源有打包好的包可以直接安装</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">yum</span> <span class="string">install</span>  <span class="string">aria2</span> <span class="string">-y</span></span><br></pre></td></tr></table></figure>
<p><a name="dsnA2"></a></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Download from WEB:</span></span><br><span class="line"><span class="string">$</span> <span class="string">aria2c</span> <span class="string">http://example.org/mylinux.iso</span></span><br><span class="line"><span class="attr">Download from 2 sources:</span></span><br><span class="line"><span class="string">$</span> <span class="string">aria2c</span> <span class="string">http://a/f.iso</span> <span class="string">ftp://b/f.iso</span></span><br><span class="line"><span class="attr">Download using 2 connections per host:</span></span><br><span class="line"><span class="string">$</span> <span class="string">aria2c</span> <span class="string">-x2</span> <span class="string">http://a/f.iso</span></span><br><span class="line"><span class="attr">BitTorrent:</span></span><br><span class="line"><span class="string">$</span> <span class="string">aria2c</span> <span class="string">http://example.org/mylinux.torrent</span></span><br><span class="line"><span class="attr">BitTorrent Magnet URI:</span></span><br><span class="line"><span class="string">$</span> <span class="string">aria2c</span> <span class="string">'magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C'</span></span><br><span class="line"><span class="attr">Metalink:</span></span><br><span class="line"><span class="string">$</span> <span class="string">aria2c</span> <span class="string">http://example.org/mylinux.metalink</span></span><br><span class="line"><span class="attr">Download URIs found in text file:</span></span><br><span class="line"><span class="string">$</span> <span class="string">aria2c</span> <span class="string">-i</span> <span class="string">uris.txt</span></span><br></pre></td></tr></table></figure>
<p><a name="L6s3I"></a></p>
<h2 id="RPC的用法"><a href="#RPC的用法" class="headerlink" title="RPC的用法"></a>RPC的用法</h2><p>使用rpc的方式可以扩展该下载工具为专用下载工具，可以被其他的下载软件调用，如 <a href="http://pandownload.com/" target="_blank" rel="noopener">pandownload</a><br>创建新的配置文件 vim ~/.aria2/aria2.conf </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span></span><br><span class="line"><span class="comment">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 文件保存相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span></span><br><span class="line"><span class="string">dir=~/downloads</span></span><br><span class="line"><span class="comment"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span></span><br><span class="line"><span class="comment">#disk-cache=32M</span></span><br><span class="line"><span class="comment"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span></span><br><span class="line"><span class="comment"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span></span><br><span class="line"><span class="comment"># falloc和trunc则需要文件系统和内核支持</span></span><br><span class="line"><span class="comment"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span></span><br><span class="line"><span class="comment">#file-allocation=none</span></span><br><span class="line"><span class="comment"># 断点续传</span></span><br><span class="line"><span class="string">continue=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载连接相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大同时下载任务数, 运行时可修改, 默认:5</span></span><br><span class="line"><span class="comment">#max-concurrent-downloads=5</span></span><br><span class="line"><span class="comment"># 同一服务器连接数, 添加时可指定, 默认:1</span></span><br><span class="line"><span class="string">max-connection-per-server=16</span></span><br><span class="line"><span class="comment"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span></span><br><span class="line"><span class="comment"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span></span><br><span class="line"><span class="string">min-split-size=10M</span></span><br><span class="line"><span class="comment"># 单个任务最大线程数, 添加时可指定, 默认:5</span></span><br><span class="line"><span class="string">split=16</span></span><br><span class="line"><span class="comment"># 整体下载速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="comment">#max-overall-download-limit=0</span></span><br><span class="line"><span class="comment"># 单个任务下载速度限制, 默认:0</span></span><br><span class="line"><span class="comment">#max-download-limit=0</span></span><br><span class="line"><span class="comment"># 整体上传速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="comment">#max-overall-upload-limit=0</span></span><br><span class="line"><span class="comment"># 单个任务上传速度限制, 默认:0</span></span><br><span class="line"><span class="comment">#max-upload-limit=0</span></span><br><span class="line"><span class="comment"># 禁用IPv6, 默认:false</span></span><br><span class="line"><span class="comment">#disable-ipv6=true</span></span><br><span class="line"><span class="comment"># 连接超时时间, 默认:60</span></span><br><span class="line"><span class="comment">#timeout=60</span></span><br><span class="line"><span class="comment"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span></span><br><span class="line"><span class="comment">#max-tries=5</span></span><br><span class="line"><span class="comment"># 设置重试等待的秒数, 默认:0</span></span><br><span class="line"><span class="comment">#retry-wait=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 进度保存相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从会话文件中读取下载任务</span></span><br><span class="line"><span class="string">input-file=/etc/aria2/aria2.session</span></span><br><span class="line"><span class="comment"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件</span></span><br><span class="line"><span class="string">save-session=/etc/aria2/aria2.session</span></span><br><span class="line"><span class="comment"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span></span><br><span class="line"><span class="comment">#save-session-interval=60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## RPC相关设置 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用RPC, 默认:false</span></span><br><span class="line"><span class="string">enable-rpc=true</span></span><br><span class="line"><span class="comment"># 允许所有来源, 默认:false</span></span><br><span class="line"><span class="string">rpc-allow-origin-all=true</span></span><br><span class="line"><span class="comment"># 允许非外部访问, 默认:false</span></span><br><span class="line"><span class="string">rpc-listen-all=true</span></span><br><span class="line"><span class="comment"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span></span><br><span class="line"><span class="comment">#event-poll=select</span></span><br><span class="line"><span class="comment"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span></span><br><span class="line"><span class="comment">#rpc-listen-port=6800</span></span><br><span class="line"><span class="comment"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span></span><br><span class="line"><span class="comment">#rpc-secret=&lt;TOKEN&gt;</span></span><br><span class="line"><span class="comment"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span></span><br><span class="line"><span class="comment">#rpc-user=&lt;USER&gt;</span></span><br><span class="line"><span class="comment"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span></span><br><span class="line"><span class="comment">#rpc-passwd=&lt;PASSWD&gt;</span></span><br><span class="line"><span class="comment"># 是否启用 RPC 服务的 SSL/TLS 加密,</span></span><br><span class="line"><span class="comment"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span></span><br><span class="line"><span class="comment">#rpc-secure=true</span></span><br><span class="line"><span class="comment"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span></span><br><span class="line"><span class="comment"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span></span><br><span class="line"><span class="comment">#rpc-certificate=/path/to/certificate.pem</span></span><br><span class="line"><span class="comment"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span></span><br><span class="line"><span class="comment">#rpc-private-key=/path/to/certificate.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## BT/PT下载相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span></span><br><span class="line"><span class="comment">#follow-torrent=true</span></span><br><span class="line"><span class="comment"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span></span><br><span class="line"><span class="string">listen-port=51413</span></span><br><span class="line"><span class="comment"># 单个种子最大连接数, 默认:55</span></span><br><span class="line"><span class="comment">#bt-max-peers=55</span></span><br><span class="line"><span class="comment"># 打开DHT功能, PT需要禁用, 默认:true</span></span><br><span class="line"><span class="string">enable-dht=false</span></span><br><span class="line"><span class="comment"># 打开IPv6 DHT功能, PT需要禁用</span></span><br><span class="line"><span class="comment">#enable-dht6=false</span></span><br><span class="line"><span class="comment"># DHT网络监听端口, 默认:6881-6999</span></span><br><span class="line"><span class="comment">#dht-listen-port=6881-6999</span></span><br><span class="line"><span class="comment"># 本地节点查找, PT需要禁用, 默认:false</span></span><br><span class="line"><span class="comment">#bt-enable-lpd=false</span></span><br><span class="line"><span class="comment"># 种子交换, PT需要禁用, 默认:true</span></span><br><span class="line"><span class="string">enable-peer-exchange=false</span></span><br><span class="line"><span class="comment"># 每个种子限速, 对少种的PT很有用, 默认:50K</span></span><br><span class="line"><span class="comment">#bt-request-peer-speed-limit=50K</span></span><br><span class="line"><span class="comment"># 客户端伪装, PT需要</span></span><br><span class="line"><span class="string">peer-id-prefix=-TR2770-</span></span><br><span class="line"><span class="string">user-agent=Transmission/2.77</span></span><br><span class="line"><span class="comment"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span></span><br><span class="line"><span class="string">seed-ratio=0</span></span><br><span class="line"><span class="comment"># 强制保存会话, 即使任务已经完成, 默认:false</span></span><br><span class="line"><span class="comment"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span></span><br><span class="line"><span class="comment">#force-save=false</span></span><br><span class="line"><span class="comment"># BT校验相关, 默认:true</span></span><br><span class="line"><span class="comment">#bt-hash-check-seed=true</span></span><br><span class="line"><span class="comment"># 继续之前的BT任务时, 无需再次校验, 默认:false</span></span><br><span class="line"><span class="string">bt-seed-unverified=true</span></span><br><span class="line"><span class="comment"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span></span><br><span class="line"><span class="string">bt-save-metadata=true</span></span><br></pre></td></tr></table></figure>
<p><br>然后直接执行命令即可启动  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">aria2c</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>https的通信过程</title>
    <url>/2019/09/02/yuque/https%E7%9A%84%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><a name="RRKMV"></a></p>
<h2 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h2><p>HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据<br><a name="vSbgT"></a></p>
<h2 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a>过程解析</h2><p>简单来说，是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1567420086204-0057a763-5e84-46ca-acb0-43f74a56ec54.png#align=left&amp;display=inline&amp;height=560&amp;originHeight=560&amp;originWidth=648&amp;size=0&amp;status=done&amp;width=648" alt><br>浏览器发起请求-&gt;服务端返回证书-&gt;浏览器使用证书（其中包含服务端的公钥）加密一段信息（pre master key + 握手信息）发给服务器-&gt;服务器使用私钥和计算出的对称密钥解密-&gt;服务器使用对称密码体系发送信息给浏览器。握手完成。</p>
<p>实际上，其中还有一些复杂的东东：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1567420030681-26ef6946-3ba4-4dcf-a643-f15f5095a5cc.png#align=left&amp;display=inline&amp;height=531&amp;originHeight=531&amp;originWidth=580&amp;size=0&amp;status=done&amp;width=580" alt><br>以上就是SSL的四次通信<br>-&gt; 客户端向服务端发送请求，包含一个随机数C,稍后用于生成”对话密钥”。<br>-&gt; 服务端返回数字证书和选定的加密算法和hash算法以及一个随机数S,稍后用于生成”对话密钥”。<br>-&gt; 客户端用自己的CA[主流的CA机构证书一般都内置在各个主流浏览器中]公钥去解密证书,如果证书有问题会提示风险<br>-&gt; 如果证书没问题客户端会生成一个随机数（pre-master key）结合随机数S和随机数C来计算出一个对称加密的密钥（enc_key=Fuc(random_C, random_S, Pre-Master）,pre-master key 将使用服务器的公钥加密；结合之前所有<strong>发送的信息和相关信息</strong>计算一个hash和一些其他信息，使用对称加密加密数据，发给服务端；并发送编码改变通知<br>-&gt; 服务器收到加密信息后，使用私钥解密（可以验证服务器端有正确的私钥）出pre-master key ，  然后结合随机数S和随机数C来计算出一个对称加密的密钥，使用这个密钥解密对称加密后的信息，其中包含hash值；同时服务器端会计算之前所有<strong>收到的信息和相关信息的</strong>hash值。这两个值做对比，以确保双方可以使用协商好的对称密钥和算法加解密信息（同时也再次确认了服务器端有正确私钥）。这一项同时也<strong>是前面发送的所有内容的hash值</strong>，用来供客户端校验。并发送编码改变通知<br>-&gt; 客户端解密接收后的信息，验证加密信息中的hash值和自己使用前面接收到的信息计算的hash值做对比，一致则验证通过，之后双方就拿着这个对称加密秘钥来进行正常的通信</p>
<p><a name="EAsjv"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>基于drone的CI-CD实践</title>
    <url>/2019/08/09/yuque/%E5%9F%BA%E4%BA%8Edrone%E7%9A%84CI-CD%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a name="C09Ql"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a name="Y4zRS"></a></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul>
<li>drone：自助式的CI/CD交互平台，提供开源版本，可私有部署</li>
<li>helm：k8s的包管理器</li>
<li>k8s：云原生..</li>
<li>gitlab：代码仓库</li>
<li>maven/dockerhub：镜像仓库<br><a name="FF3Ef"></a><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1565320073159-6576566d-21d0-4785-9d01-48c9aa3eb7f1.png#align=left&amp;display=inline&amp;height=1084&amp;name=CICD%E6%B5%81%E7%A8%8B.png&amp;originHeight=1084&amp;originWidth=1564&amp;size=120542&amp;status=done&amp;width=1564" alt="CICD流程.png"><br><a name="ue5t1"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>安装方式推荐docker方式，一条命令完事儿，drone需要安装drone-server和drone-agent，参考：<a href="https://docs.drone.io/installation/gitlab/" target="_blank" rel="noopener">https://docs.drone.io/installation/gitlab/</a>  </li>
</ul>
<p>安装server：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --volume=/var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  --volume=/var/lib/drone:/data \</span><br><span class="line">  --env=DRONE_GIT_ALWAYS_AUTH=false \</span><br><span class="line">  --env=DRONE_GITLAB_SERVER=http://gitlab.xxx.com \</span><br><span class="line">  --env=DRONE_GITLAB_CLIENT_ID=9d71bdccd11156913a475891ab082f61677aae816e40911896cb82c17fcfc87e \</span><br><span class="line">  --env=DRONE_GITLAB_CLIENT_SECRET=8039aff4d23560355e76e7855b409399c119fdb4005c9d02a2291bfe05d5b6da \</span><br><span class="line">  --env=DRONE_RUNNER_CAPACITY=2 \</span><br><span class="line">  --env=DRONE_SERVER_HOST=drone.test.com \</span><br><span class="line">  --env=DRONE_USER_CREATE=username:xxx,admin:true\</span><br><span class="line">  --env=DRONE_SERVER_PROTO=http \</span><br><span class="line">  --env=DRONE_TLS_AUTOCERT=false \</span><br><span class="line">  --env=DRONE_USER_FILTER=xxx \</span><br><span class="line">  --env=DRONE_RPC_SECRET=b00553e8d490f13d296fa0f8a3bdd630 \</span><br><span class="line">  --publish=80:80 \</span><br><span class="line">  --publish=443:443 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --detach=true \</span><br><span class="line">  --name=drone \</span><br><span class="line">  drone/drone:1.2.3-linux-amd64</span><br></pre></td></tr></table></figure>
<p>安装agent：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-e DRONE_RPC_PROTO=http \</span><br><span class="line">-e DRONE_RPC_HOST=drone.test.com \</span><br><span class="line">-e DRONE_RPC_SECRET=b00553e8d490f13d296fa0f8a3bdd630 \</span><br><span class="line">-e DRONE_RUNNER_CAPACITY=2 \</span><br><span class="line">-e DRONE_RUNNER_NAME=$&#123;HOSTNAME&#125; \</span><br><span class="line">-p 3001:3000 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">--restart always \</span><br><span class="line">--name runner \</span><br><span class="line">drone/agent:1.2.3-linux-amd64</span><br></pre></td></tr></table></figure>
<p><a name="LGvnT"></a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a name="XJ8ld"></a></p>
<h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>首先，登陆安装时候在server那里指定的变量（DRONE_GITLAB_SERVER）对应的地址：<a href="http://drone.test.com" target="_blank" rel="noopener">http://drone.test.com</a> ,会自动跳转到gitlab进行认证授权  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1565320678830-9a30140a-013a-41a3-a81c-6daa2d3fb550.png#align=left&amp;display=inline&amp;height=350&amp;name=image.png&amp;originHeight=350&amp;originWidth=883&amp;size=23523&amp;status=done&amp;width=883" alt="image.png"><br>然后会跳转到drone的界面，这里我们可以激活需要做cicd的项目  <img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1565320725660-96e989b6-9d90-412e-91ac-072bbc01a946.png#align=left&amp;display=inline&amp;height=264&amp;name=image.png&amp;originHeight=264&amp;originWidth=1004&amp;size=22396&amp;status=done&amp;width=1004" alt="image.png"><br>要做cicd的开发，只需要在项目的根目录添加 <strong> .drone.yml </strong> 文件（也支持自定义的文件）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">pipeline</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">clone:</span></span><br><span class="line">  <span class="attr">depth:</span> <span class="number">50</span></span><br><span class="line"><span class="attr">trigger:</span></span><br><span class="line"><span class="comment">#  branch:</span></span><br><span class="line"><span class="comment">#  - master</span></span><br><span class="line">  <span class="attr">event:</span></span><br><span class="line">    <span class="attr">include:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">push</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tag</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">promote</span></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">go-build</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">golang</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">go</span> <span class="string">build</span> <span class="string">-o</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ls</span> <span class="string">-l</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">./hello</span></span><br><span class="line"> </span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker</span>  </span><br><span class="line">  <span class="attr">image:</span> <span class="string">plugins/docker</span></span><br><span class="line">  <span class="attr">settings:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">imdingtalk/hello</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">$&#123;DRONE_TAG&#125;</span></span><br><span class="line">  <span class="comment">#其他内置变量参考</span></span><br><span class="line">  <span class="comment">#https://docs.drone.io/reference/environ/</span></span><br><span class="line"><span class="comment"># 这里发布的时候，使用自己打包的helm+kubectl的镜像，包含密钥信息</span></span><br><span class="line"><span class="comment"># 测试环境直接发布，不需要手动触发，生产环境一般手动触发</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">helm-kubectl-deploy</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">xxx/helm:3.0</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">helm</span> <span class="string">ls</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-n</span> <span class="string">ops</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">helm</span>  <span class="string">upgrade</span>  <span class="string">--set</span> <span class="string">image.tag=$&#123;DRONE_TAG&#125;</span>  <span class="string">hello</span> <span class="string">stable/hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">helm</span> <span class="string">history</span> <span class="string">hello</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">##以下是测试手动触发任务，在自动触发时候不会执行以下任务，因为有when条件</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">production</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">golang</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"production"</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">event:</span> <span class="string">[</span> <span class="string">promote</span> <span class="string">]</span></span><br><span class="line">    <span class="attr">target:</span> <span class="string">[</span> <span class="string">prod</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">testing</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">golang</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"testing"</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">event:</span> <span class="string">[</span> <span class="string">promote</span> <span class="string">]</span></span><br><span class="line">    <span class="attr">target:</span> <span class="string">[</span> <span class="string">testing</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
<p><a name="x1Qyb"></a></p>
<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>手动触发需要drone的<a href="https://docs.drone.io/cli/install/" target="_blank" rel="noopener">客户端</a>，一般用于生产部署    </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">drone</span> <span class="string">build</span> <span class="string">promote</span>  <span class="string">xxx/drone</span>  <span class="number">130</span>    <span class="string">prod</span></span><br><span class="line"><span class="string">这里的130，和prod对应前面.drone.yml文件中的when条件，触发对应的任务</span></span><br><span class="line"><span class="comment">#USAGE:</span></span><br><span class="line"><span class="comment">#   drone build promote [command options] &lt;repo/name&gt; &lt;build&gt; &lt;environment&gt;</span></span><br></pre></td></tr></table></figure>
<p><a name="lnD0f"></a></p>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p><a name="q6loS"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.drone.io/" target="_blank" rel="noopener">https://docs.drone.io/</a></p>
]]></content>
  </entry>
  <entry>
    <title>helm本地仓库实践</title>
    <url>/2019/08/08/yuque/helm%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a name="JtFPD"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Helm是查找，共享和使用为Kubernetes构建的软件的最佳方式<br><a name="L455f"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接在github获取： <a href="https://github.com/helm/helm" target="_blank" rel="noopener">https://github.com/helm/helm</a>  <br>在集群中初始化  <br>首先声明rbac  <code>vim rbac-config.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>
<p><code>kubectl apply -f `</code>rbac-config.yaml`<br>使用阿里云的仓库初始化<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm init  --stable-repo-url  https://apphub.aliyuncs.com/  --service-account tiller</span><br></pre></td></tr></table></figure></p>
<p>初始化后，在kube-system里面会创建一个deploy，但是里面的镜像是谷歌的，需要手动改一下  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span>  <span class="string">edit</span>  <span class="string">deployments.</span>  <span class="string">-n</span> <span class="string">kube-system</span>  <span class="string">tiller-deploy</span></span><br><span class="line"><span class="comment">#在helm -v3中删除了tiller组件</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">automountServiceAccountToken:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TILLER_NAMESPACE</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">kube-system</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TILLER_HISTORY_MAX</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"0"</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">imdingtalk/tiller:v2.14.1</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>至此，helm基础环境搭建完毕<br><a name="zrOHt"></a></p>
<h2 id="helm本地仓库"><a href="#helm本地仓库" class="headerlink" title="helm本地仓库"></a>helm本地仓库</h2><p>部署参考：<a href="https://github.com/helm/helm/blob/master/docs/chart_repository.md" target="_blank" rel="noopener">helm存储库指南</a>  <br>可以直接在本地使用helm启用，或用于生成索引  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm serve --repo-path ./charts </span><br><span class="line"><span class="comment">#在helm v3中删除了这个</span></span><br></pre></td></tr></table></figure>
<p>或者使用开源方案chartmuseum    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d   -p 8080:8080   -v $(<span class="built_in">pwd</span>)/charts:/charts   -e DEBUG=<span class="literal">true</span>   -e STORAGE=<span class="built_in">local</span>   -e STORAGE_LOCAL_ROOTDIR=/charts   chartmuseum/chartmuseum</span><br></pre></td></tr></table></figure>
<p><a name="lYPC3"></a></p>
<h3 id="本地repo的使用"><a href="#本地repo的使用" class="headerlink" title="本地repo的使用"></a>本地repo的使用</h3><p>把本地参考添加到helm的repo  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm   repo add   <span class="built_in">local</span>  http://localhost:8080</span><br></pre></td></tr></table></figure>
<p>创建自己的charts  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm create hello</span><br></pre></td></tr></table></figure>
<p>上传自己的charts  ，helm push插件安装： <a href="https://github.com/chartmuseum/helm-push" target="_blank" rel="noopener">https://github.com/chartmuseum/helm-push</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm push hello <span class="built_in">local</span>/</span><br></pre></td></tr></table></figure>
<p>在本地仓库中搜索自己的charts  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm search <span class="built_in">local</span>/</span><br></pre></td></tr></table></figure>
<p>安装自己的charts<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install --name hello bendi/hello</span><br></pre></td></tr></table></figure></p>
<p>升级自己的应用  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade -f values.yaml  hello  .</span><br></pre></td></tr></table></figure>
<p>删除使用helm的应用  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm delete  hello</span><br></pre></td></tr></table></figure>
<p>清理已经删除的charts，也可以在删除的时候就做  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm del --purge hello</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>HSTS域名实践</title>
    <url>/2019/07/31/yuque/HSTS%E5%9F%9F%E5%90%8D%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a name="5YWIP"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>大家比较熟悉的是https，在传输数据之前，https会验证客户和服务器直接的信任关系，通过握手来确认这种认证，但是当网站传输协议从 HTTP 到 HTTPS 之后，数据传输真的安全了吗？  </p>
<p>由于用户习惯，通常准备访问某个网站时，在浏览器中只会输入一个域名，而不会在域名前面加上 http:// 或者 https://，而是由浏览器自动填充，当前所有浏览器默认填充的都是http://。一般情况网站管理员会采用了 301/302 跳转的方式由 HTTP 跳转到 HTTPS，但是这个过程总使用到 HTTP 因此容易发生劫持，受到第三方的攻击。如图：  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564578211609-d2d65248-7eea-4719-9ceb-ffefef77a6a1.png#align=left&amp;display=inline&amp;height=287&amp;originHeight=287&amp;originWidth=488&amp;size=0&amp;status=done&amp;width=488" alt><br><a name="w8vmp"></a></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在443的server段添加如下配置：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_header Strict-Transport-Security <span class="string">"max-age=63072000; includeSubdomains; preload"</span>;</span><br></pre></td></tr></table></figure>
<p>在80端口的server端添加重定向：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">return</span> 301 https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure>
<p>重启服务后的效果  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564579596091-366f5647-4c25-4e72-bcf1-29afdcfce7fa.png#align=left&amp;display=inline&amp;height=503&amp;name=image.png&amp;originHeight=503&amp;originWidth=1074&amp;size=47840&amp;status=done&amp;width=1074" alt="image.png"><br>启用hsts后，浏览器还是存在首次访问使用HTTP请求的情况，可以在<a href="https://hstspreload.org/" target="_blank" rel="noopener">这里</a> ，把我们的域名添加到浏览器的预加载里面，浏览器遇到该域名的时候即可实现首次访问的时候就使用https的方式请求，进一步提高安全性<br><a name="FpYNA"></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用通配的证书的时候，开启HSTS，在使用HTTP请求网站的时候，由于HSTS需要验证，在请求的时候，浏览器会直接使用https发起请求，如我们要访问<a href="http://dingtalk.pub;浏览器会直接使用https发起访问，即使用https://dingtalk.pub发起访问，本来如果正常访问http://dingtalk.pub，服务器会直接重定向为https://www.dingtalk.pub;这样不会引起证书问题，但是启用HSTS后，会存在我们的通配证书对根域名" target="_blank" rel="noopener">http://dingtalk.pub;浏览器会直接使用https发起访问，即使用https://dingtalk.pub发起访问，本来如果正常访问http://dingtalk.pub，服务器会直接重定向为https://www.dingtalk.pub;这样不会引起证书问题，但是启用HSTS后，会存在我们的通配证书对根域名</a>  dingtalk.pub的不信任问题，这个，还不知道怎么处理，后面再跟进<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564580110391-df53a57c-d91c-4831-b342-a2ac49e4b587.png#align=left&amp;display=inline&amp;height=675&amp;name=image.png&amp;originHeight=675&amp;originWidth=1012&amp;size=76206&amp;status=done&amp;width=1012" alt="image.png"><br>这个问题将直接导致谷歌浏览器不接受这样不安全的访问  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564580577242-c323aee5-6a3d-4005-86dc-6d1547f02110.png#align=left&amp;display=inline&amp;height=666&amp;name=image.png&amp;originHeight=666&amp;originWidth=860&amp;size=75243&amp;status=done&amp;width=860" alt="image.png"><br>关于这个问题的处理 ~~ ~~<br>额，之前没有发现一个证书是可以颁发给多个域名的，同时颁发给dingtalk.pub和*.dingtalk.pub就可以了嘛，蠢了蠢了;后面再测试，甚至可以颁发给不同的根域</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成证书的时候这样生成 </span></span><br><span class="line"> acme.sh --issue --dns dns_ali -d dingtalk.pub -d *.dingtalk.pub -d *.edgon.cn</span><br><span class="line"><span class="comment">#安装证书</span></span><br><span class="line"> acme.sh  --install-cert  -d  dingtalk.pub   -d *.dingtalk.pub        --key-file   /etc/nginx/ssl/dingtalk.key         --fullchain-file /etc/nginx/ssl/dingtalk.cer         --reloadcmd  <span class="string">"systemctl restart nginx "</span></span><br><span class="line">server &#123;</span><br><span class="line">      listen 443;</span><br><span class="line">      .....</span><br><span class="line"></span><br><span class="line">      ssl_certificate <span class="string">"/etc/nginx/ssl/dingtalk.cer"</span>;</span><br><span class="line">      ssl_certificate_key <span class="string">"/etc/nginx/ssl/dingtalk.key"</span>;</span><br><span class="line">      ......</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>再次访问，就没有报错了，爽歪歪  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564582753598-3f48debe-6914-434e-bc14-fa887c0639ca.png#align=left&amp;display=inline&amp;height=746&amp;name=image.png&amp;originHeight=746&amp;originWidth=1067&amp;size=105163&amp;status=done&amp;width=1067" alt="image.png"><br>这样还满足了<a href="https://hstspreload.org/" target="_blank" rel="noopener">HSTS preload</a>网站的要求  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564584454484-d79d9064-ea27-4a11-b1e7-408f87903cf1.png#align=left&amp;display=inline&amp;height=704&amp;name=image.png&amp;originHeight=704&amp;originWidth=958&amp;size=66201&amp;status=done&amp;width=958" alt="image.png"><br><a href="https://www.ssllabs.com/" target="_blank" rel="noopener">https://www.ssllabs.com/</a> 这里来测试一波<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564585130747-5e9854e3-6930-45c2-a6db-db25deb26979.png#align=left&amp;display=inline&amp;height=510&amp;name=image.png&amp;originHeight=510&amp;originWidth=1100&amp;size=46978&amp;status=done&amp;width=1100" alt="image.png">调试<br>chrome://net-internals/#hsts<br><a name="9RISY"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/upyun/p/7447977.html" target="_blank" rel="noopener">从 HTTP 到 HTTPS 再到 HSTS</a>  <br><a href="https://blog.hcl.moe/archives/729" target="_blank" rel="noopener">Nginx下HTTP强制重定向至HTTPS</a><br></p>
]]></content>
  </entry>
  <entry>
    <title>基于acme的域名通配证书配置和自动续期</title>
    <url>/2019/07/31/yuque/%E5%9F%BA%E4%BA%8Eacme%E7%9A%84%E5%9F%9F%E5%90%8D%E9%80%9A%E9%85%8D%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE%E5%92%8C%E8%87%AA%E5%8A%A8%E7%BB%AD%E6%9C%9F/</url>
    <content><![CDATA[<p><a name="jQB1K"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在我们的环境中要求，所有的请求都使用https的方式，如果购买商用证书，感觉成本很过分。于是测试使用let’s encrypt wildcard的方式来实现</p>
<p><a name="qsxph"></a></p>
<h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><p><a href="http://acme.sh/" target="_blank" rel="noopener">http://acme.sh</a>  <br>一个实现ACME客户端协议的纯Unix shell脚本，用于各种证书的生成。<br><a name="8FY80"></a></p>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><p>这个在项目的readme已经很完善了，结合自己的使用，来简要说明下  <br>安装很简单, 一个命令:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl  https://get.acme.sh | sh</span><br></pre></td></tr></table></figure></p>
<p><a name="7a2u8"></a></p>
<h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h3><p>我这里使用的阿里的域名，使用的dnsapi方式验证  <br>首先去获取API的的key和secret，<a href="https://ak-console.aliyun.com/#/accesskey" target="_blank" rel="noopener">https://ak-console.aliyun.com/#/accesskey</a> <br>或 <a href="https://ram.console.aliyun.com/permissions" target="_blank" rel="noopener">https://ram.console.aliyun.com/permissions</a> <br>给与dns权限  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564544275324-d63aafe4-500d-4ef4-accf-a5fe68d15e48.png#align=left&amp;display=inline&amp;height=514&amp;name=image.png&amp;originHeight=514&amp;originWidth=889&amp;size=41405&amp;status=done&amp;width=889" alt="image.png"><br>然后选择该有权限的用户，创建新的accessKey  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564544405670-bcb9494d-b735-4a8e-9b38-9d19e2a1cf7e.png#align=left&amp;display=inline&amp;height=592&amp;name=image.png&amp;originHeight=592&amp;originWidth=1245&amp;size=79651&amp;status=done&amp;width=1245" alt="image.png"><br>使用刚刚获取的key来配置acme需要的信息  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> Ali_Key=<span class="string">"sdfsdfsdfljlbjkljlkjsdfoiwje"</span></span><br><span class="line"><span class="built_in">export</span> Ali_Secret=<span class="string">"jlsdflanljkljlfdsaklkjflsa"</span></span><br><span class="line"><span class="comment">#Ali_Key和Ali_Secret将保存在〜/.acme.sh/account.conf中，并在需要时重复使用。</span></span><br><span class="line"><span class="comment">#颁发证书</span></span><br><span class="line">acme.sh --issue --dns dns_ali -d *.demo.dingtalk.pub</span><br><span class="line"><span class="comment">#建议颁发证书的时候包含根域名</span></span><br><span class="line"> acme.sh --issue --dns dns_ali -d dingtalk.pub -d *.dingtalk.pub</span><br><span class="line"> acme.sh --issue --dns dns_ali -d *.demo.dingtalk.pub -d demo.dingtalk.pub</span><br><span class="line"><span class="comment">#安装证书  </span></span><br><span class="line">acme.sh  --install-cert  -d  *.demo.dingtalk.pub           --key-file   /etc/nginx/ssl/demo.dingtalk.pub.key         --fullchain-file /etc/nginx/ssl/demofullchain.cer         --reloadcmd  <span class="string">"systemctl restart nginx "</span></span><br><span class="line"><span class="comment">#至此证书就已经颁发，并且key和cer已经被程序放在/etc/nginx/ssl/目录下，并且定期自动更新</span></span><br><span class="line"><span class="comment">#acme不会修改任何配置，ssl的相关配置，需要自己手动修改配置文件</span></span><br><span class="line"><span class="comment">#自动更新的脚本会被自动添加到定时器</span></span><br><span class="line">[root@iZwz96589vyznjacr6y3ayZ ~]<span class="comment"># crontab  -l</span></span><br><span class="line">58 0 * * * <span class="string">"/root/.acme.sh"</span>/acme.sh --cron --home <span class="string">"/root/.acme.sh"</span> &gt; /dev/null</span><br><span class="line"><span class="comment">#可以手动强制更新证书</span></span><br><span class="line"><span class="string">"/root/.acme.sh"</span>/acme.sh --cron --home <span class="string">"/root/.acme.sh"</span>  --force</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>nginx支持webp的图片智适应下发</title>
    <url>/2019/07/25/yuque/nginx%E6%94%AF%E6%8C%81webp%E7%9A%84%E5%9B%BE%E7%89%87%E6%99%BA%E9%80%82%E5%BA%94%E4%B8%8B%E5%8F%91/</url>
    <content><![CDATA[<p><a name="N47fy"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在同一个页面加载多张大图的时候，页面的载入速度，在我们的项目中，取决于图片的大小，页面总加载时间3s，图片加载时间将近1.5s。f12 查看分析，主要的耗时在图片加载，要怎么加快图片的加载呢，首先想到的就是图片的压缩<br><a name="wruh1"></a></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在nginx中添加对图片的处理逻辑<br>首先在HTTP这里添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">   xxx...</span><br><span class="line">    map $http_accept $webp_ext &#123;</span><br><span class="line">    default &quot;&quot;;</span><br><span class="line">    &quot;~*webp&quot; &quot;.webp&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的意思是，判断HTTP的请求头是否包含webp，谷歌浏览器在请求图片时候的请求头如下<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564035205265-05be1e3a-66da-45e0-b907-5163a1dd6c46.png#align=left&amp;display=inline&amp;height=48&amp;name=image.png&amp;originHeight=48&amp;originWidth=936&amp;size=8272&amp;status=done&amp;width=936" alt="image.png">如果包含，这里将设置一个变量<strong>webp_ext</strong>，它的值是<strong>.webp</strong><br>,这样，我们的请求的浏览器如果支持webp的图片格式，我们在server层的配置将尝试给浏览器返回一个webp格式的图片  <br>在server层添加如下配置 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ .*\.(jpg|jpeg|gif|png)$ &#123;</span><br><span class="line">add_header Vary Accept;</span><br><span class="line">try_files $uri$webp_ext $uri =404;</span><br><span class="line">root /usr/local/openresty/nginx/html;</span><br></pre></td></tr></table></figure>
<p>这里，让我们所有请求图片的请求，使用try_files方法，首先尝试返回$uri$webp_ext所指向的图片，即如果原请求是xxx.png，则nginx这里尝试返回xxx.png.webp 。如果浏览器的请求头中没有webp这个关键字，那么这个变量的值就是原始的uri .即直接返回xxx.png 的原始图片，以适应不支持webp的浏览器  <br>前提是，我们的网站目录中需要包含对应图片的webp格式，这个可以一次性生成，也可以配置nginx-lua在访问的时候实时生成。实时生成后面再研究，我这里在测试环境中，仅尝试一次性生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install libwebp-tools</span><br><span class="line">cwebp  -q 100  1.png -o 1.png.webp</span><br></pre></td></tr></table></figure>
<p>下图为两个格式的加载时间对比  <br>使用原始图像  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564035734808-0df00759-8655-4b7b-9728-6e4478aefe33.png#align=left&amp;display=inline&amp;height=104&amp;name=image.png&amp;originHeight=104&amp;originWidth=1904&amp;size=10870&amp;status=done&amp;width=1904" alt="image.png"><br>使用压缩的webp图像<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1564035765352-fc2e6cbf-7403-444d-baa5-831c94d17680.png#align=left&amp;display=inline&amp;height=88&amp;name=image.png&amp;originHeight=88&amp;originWidth=1900&amp;size=10028&amp;status=done&amp;width=1900" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>k8s使用自定义的指标进行hpa</title>
    <url>/2019/07/07/yuque/k8s%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%8C%87%E6%A0%87%E8%BF%9B%E8%A1%8Chpa/</url>
    <content><![CDATA[<p><a name="sWPgX"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Horizontal Pod Autoscaling，简称HPA，是Kubernetes中实现POD水平自动伸缩的功能。为什么要水平而不叫垂直, 那是因为自动扩展主要分为两种:<br>水平扩展(scale out)，针对于实例数目的增减<br>垂直扩展(scal up)，即单个实例可以使用的资源的增减, 比如增加cpu和增大内存<br>而HPA属于前者。它可以根据CPU使用率或应用自定义metrics自动扩展Pod数量(支持 replication controller、deployment 和 replica set)<br><a name="YJ5y8"></a></p>
<h2 id="实施过程"><a href="#实施过程" class="headerlink" title="实施过程"></a>实施过程</h2><p><a name="3p6yS"></a></p>
<h3 id="部署prometheus"><a href="#部署prometheus" class="headerlink" title="部署prometheus"></a>部署prometheus</h3><p>自定义的指标需要从集群中抓取，而这些指标的抓取需要prometheus的支持，这里推荐一个最佳实践，基于prometheus-operator的全栈k8s监控项目： <a href="https://github.com/coreos/kube-prometheus" target="_blank" rel="noopener">kube-prometheus</a> ,部署该项目后，集群将拥有全栈的监控功能，为下一步，部署自定义的指标做准备<br><a name="2M9uT"></a></p>
<h3 id="部署prometheus-adapter"><a href="#部署prometheus-adapter" class="headerlink" title="部署prometheus-adapter"></a>部署prometheus-adapter</h3><p>该组件，提供了自定义指标的功能，用于将prometheus中的指标抓取为api资源，以便在hpa的定义中使用抓取到的metrics，官方推荐的安装方式是这样的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果所在环境全局翻墙的话，这个办法倒是挺好的</span></span><br><span class="line">$ helm install --name my-release stable/prometheus-adapter</span><br></pre></td></tr></table></figure>
<p>但是，由于国内环境的原因，我们可以把该资源导出为yaml文件，以便在本地部署或修改；在能够通外网的vps上操作一波</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全栈的helm工具，需要翻墙，在本地使用的话，我们可以仅仅初始化helm客户端</span></span><br><span class="line">helm  init --client-only</span><br><span class="line"><span class="comment">#将模板下载到本地</span></span><br><span class="line">helm  fetch --untar  --untardir . stable/prometheus-adapter</span><br><span class="line"><span class="comment">#使用模板生成配置文件</span></span><br><span class="line">helm  template prometheus-adapter   --<span class="built_in">set</span> prometheus.url=http://prometheus.monitoring.svc &gt; prometheus-adapter.yaml</span><br><span class="line"><span class="comment">#这样，就生成了本地配置文件prometheus-adapter.yaml，image，镜像字段必须要修改为国内可以下载到的；修改其中的字段或者其他值，可以参考文末链接</span></span><br></pre></td></tr></table></figure>
<p>使用生成的yaml本地文件，在墙内的服务器上执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f prometheus-adapter.yaml</span><br><span class="line"><span class="comment">#查看自定义的指标是否生效</span></span><br><span class="line">kubectl get --raw <span class="string">"/apis/custom.metrics.k8s.io/"</span> | jq</span><br><span class="line">kubectl get --raw <span class="string">"/apis/custom.metrics.k8s.io/v1beta1/"</span> | jq</span><br><span class="line"><span class="comment">#如果有数据返回的话，就已经可以使用了</span></span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://github.com/helm/charts/blob/master/stable/prometheus-adapter/README.md" target="_blank" rel="noopener">Prometheus Adapter</a></p>
]]></content>
  </entry>
  <entry>
    <title>mongodb用户权限管理</title>
    <url>/2019/06/23/yuque/mongodb%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><a name="Y0MTa"></a></p>
<h2 id="小小记录一下"><a href="#小小记录一下" class="headerlink" title="小小记录一下"></a>小小记录一下</h2><p>mongo自己有很多的内置角色，权限的管理，可以按照k8s的理解来处理，即RBAC 。</p>
<ol>
<li>内置角色可以直接使用，默认的角色有合理的权限划分，所以我们只要创建用户并且关联角色就可以了</li>
<li>角色具有namespace属性，在mongo中，不同数据库（类似namespace）的用户，即使是相同的用户，可以授予不同的角色；即用户和他关联的角色只有用户在特定的数据库下生效，并且，认证的时候也得选择特定的数据库来认证（区别于MySQL的，使用一个用户登录，不需要指定用来认证的数据库）<br><a name="3wXb2"></a><h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#初始化副本集</span></span><br><span class="line">use admin</span><br><span class="line">rs.initiate()</span><br><span class="line"><span class="comment">#查看状态</span></span><br><span class="line">rs.status()</span><br><span class="line">rs.isMaster()</span><br><span class="line"><span class="comment">#添加副本集成员</span></span><br><span class="line">rs.add(<span class="string">'172.16.13.xx:27018'</span>)</span><br><span class="line"><span class="comment">#删除节点</span></span><br><span class="line">rs.remove(<span class="string">'172.16.13.xx:27018'</span>)</span><br><span class="line"><span class="comment">#查看副本集配置</span></span><br><span class="line">rs.conf()</span><br><span class="line"><span class="comment">#恢复步骤</span></span><br><span class="line">首先恢复一个主节点，然后其他节点，再加入即可</span><br><span class="line"></span><br><span class="line"><span class="comment">#安全管理</span></span><br><span class="line">https://docs.mongodb.com/manual/reference/built-in-roles/</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建用户</span></span><br><span class="line"></span><br><span class="line">use admin</span><br><span class="line"></span><br><span class="line">db.createUser( &#123;user: <span class="string">"root"</span>,<span class="built_in">pwd</span>: <span class="string">"root"</span>,roles: [ &#123; role: <span class="string">"userAdminAnyDatabase"</span>, db: <span class="string">"admin"</span> &#125; ]&#125;)            <span class="comment">#超级用户角色</span></span><br><span class="line">db.createUser( &#123;user: <span class="string">"cluster"</span>,<span class="built_in">pwd</span>: <span class="string">"cluster"</span>,roles: [ &#123; role: <span class="string">"clusterAdmin"</span>, db: <span class="string">"admin"</span> &#125; ]&#125;)  <span class="comment">#集群管理员</span></span><br><span class="line">db.createUser( &#123;user: <span class="string">"test"</span>,<span class="built_in">pwd</span>: <span class="string">"test"</span>,roles: [ &#123; role: <span class="string">"readWrite"</span>, db: <span class="string">"test"</span> &#125; ]&#125;)       <span class="comment">#数据库用户角色，一般用户使用</span></span><br><span class="line">db.createUser( &#123;user: <span class="string">"dbbackup"</span>,<span class="built_in">pwd</span>: <span class="string">"dbbackup"</span>,roles: [ &#123; role: <span class="string">"backup"</span>, db: <span class="string">"admin"</span> &#125; ]&#125;)  <span class="comment">#系统内置备份角色</span></span><br><span class="line">db.createUser( &#123;user: <span class="string">"restore"</span>,<span class="built_in">pwd</span>: <span class="string">"restore"</span>,roles: [ &#123; role: <span class="string">"restore"</span>, db: <span class="string">"admin"</span> &#125; ]&#125;)   <span class="comment">#系统内置恢复角色</span></span><br><span class="line"></span><br><span class="line">mongo  -u <span class="built_in">test</span> -p <span class="built_in">test</span>  --port 27017 --authenticationDatabase <span class="built_in">test</span></span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line"><span class="comment">#查看用户的角色和拥有的权限</span></span><br><span class="line">db.getUser(<span class="string">'test'</span>)</span><br><span class="line">db.system.users.find()  <span class="comment">#所有ns</span></span><br><span class="line">db.getUsers()     <span class="comment">#当前ns（db）下</span></span><br><span class="line">db.getRole(<span class="string">"backup"</span>,&#123; showPrivileges: <span class="literal">true</span> &#125; )</span><br><span class="line"><span class="comment">#授予新的角色</span></span><br><span class="line">use admin </span><br><span class="line">db.grantRolesToUser(</span><br><span class="line">    <span class="string">"cluster"</span>,</span><br><span class="line">    [</span><br><span class="line">      &#123; role: <span class="string">"clusterAdmin"</span>, db: <span class="string">"admin"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="comment">#撤销角色</span></span><br><span class="line">db.revokeRolesFromUser(</span><br><span class="line">    <span class="string">"cluster"</span>,</span><br><span class="line">    [</span><br><span class="line">      &#123; role: <span class="string">"userAdminAnyDatabase"</span>, db: <span class="string">"admin"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="comment">#删除用户</span></span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.dropUser(<span class="string">"dbbackup"</span>)</span><br><span class="line"><span class="comment">#监控，使用前面创建的admin用户登录</span></span><br><span class="line"><span class="comment">#https://github.com/percona/mongodb_exporter</span></span><br><span class="line">db.getSiblingDB(<span class="string">"admin"</span>).createUser(&#123;</span><br><span class="line">    user: <span class="string">"mongodb_exporter"</span>,</span><br><span class="line">    <span class="built_in">pwd</span>: <span class="string">"s3cr3tpassw0rd"</span>,</span><br><span class="line">    roles: [</span><br><span class="line">        &#123; role: <span class="string">"clusterMonitor"</span>, db: <span class="string">"admin"</span> &#125;,</span><br><span class="line">        &#123; role: <span class="string">"read"</span>, db: <span class="string">"local"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">export</span> MONGODB_URI=<span class="string">'mongodb://mongodb_exporter:s3cr3tpassw0rd@172.16.13.44:27017,172.16.13.44:27018,172.16.13.44:27019'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定WT存储引擎内部cache的内存用量上限,防止无限使用，造成oom</span></span><br><span class="line">db.adminCommand(&#123;setParameter: 1, wiredTigerEngineRuntimeConfig: <span class="string">"cache_size=8G"</span>&#125;)</span><br><span class="line"><span class="comment">#指定最大并发写事务数</span></span><br><span class="line"><span class="comment">#对于写频繁的服务，通过mongostat查看运行状态，如果qw持续较高、aw经常是128（默认值），说明写请求发生排队，同时WT无法提供更高的并发写，此时观察CPU负载，如果负载不高（相对于核数，CPU未充分利用），尝试调高此参数，能够一定程度上缓解问题，即使出现qw高，往往也是短暂的，可能下一秒恢复正常。</span></span><br><span class="line">调高此参数，相当于压榨CPU，CPU负载较之前会有一定增加，如果负载在合理范围内，可以接受；负载过高的话，建议扩容。</span><br><span class="line">建议根据实际情况动态调整，并持续观察效果，找到一个合理的值。</span><br><span class="line"><span class="comment">#查看当前配置</span></span><br><span class="line">db.adminCommand(&#123;getParameter: 1, wiredTigerConcurrentWriteTransactions: 1&#125;)</span><br><span class="line"><span class="comment">#调整配置</span></span><br><span class="line">db.adminCommand(&#123;setParameter: 1, wiredTigerConcurrentWriteTransactions: 512&#125;)</span><br><span class="line"><span class="comment">#如果cache体积较大、读写频繁，那么需要更多的eviction线程</span></span><br><span class="line">db.adminCommand(&#123;setParameter: 1, wiredTigerEngineRuntimeConfig: <span class="string">"eviction=(threads_min=1,threads_max=8)"</span>&#125;)</span><br><span class="line"><span class="comment">#一些命令</span></span><br><span class="line">mongostat  -u cluster -p cluster --authenticationDatabase admin</span><br><span class="line"><span class="comment">#空间清理</span></span><br><span class="line">db.repairDatabase() </span><br><span class="line">db.foo.drop()  //删除foo这个collection，（show collection已经看不到foo了）但是查看数据文件发现大小不变，Mongodb不会自动释放文件空间</span><br></pre></td></tr></table></figure>
<p><a name="syD63"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>那些内置的角色：<a href="https://docs.mongodb.com/manual/reference/built-in-roles/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/built-in-roles/</a></p>
]]></content>
  </entry>
  <entry>
    <title>mongodb副本集搭建</title>
    <url>/2019/06/23/yuque/mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><a name="h1Kc8"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>副本集是mongoDB副本所组成的一个集群，集群中没有特定的主库，主库是选举产生，如果主库down了，会再选举出一台主库</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1561268249798-eeb9855b-e9b1-44d0-89af-babaee637876.png#align=left&amp;display=inline&amp;height=265&amp;originHeight=265&amp;originWidth=700&amp;size=0&amp;status=done&amp;width=700" alt><br>正常状态下拓扑<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1561268257542-862cdbf1-dfb9-47b9-918f-4168d15bd838.png#align=left&amp;display=inline&amp;height=379&amp;originHeight=379&amp;originWidth=500&amp;size=0&amp;status=done&amp;width=500" alt><br>故障切换过程</p>
<p>副本集有以下特点：<br>1. 最小构成是：primary，secondary，arbiter，一般部署是：primary，2 secondary。<br>2. 成员数应该为奇数，如果为偶数的情况下添加arbiter，arbiter不保存数据，只投票。<br>3. 最大50 members，但是只能有 7 voting members，其他是non-voting members。<br><a name="VZ94T"></a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>下载mongod：<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a><br>加入到系统路径：chmod +x mongod &amp;&amp; cp mongod /usr/bin/<br>创建用户并设置密码： useradd mongod &amp;&amp; passwd mongod<br>编辑配置文件  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mongod.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for documentation of all options, see:</span></span><br><span class="line"><span class="comment">#   http://docs.mongodb.org/manual/reference/configuration-options/</span></span><br><span class="line"><span class="comment"># where to write logging data.</span></span><br><span class="line"><span class="attr">systemLog:</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">logAppend:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/var/log/mongodb/mongod1.log</span></span><br><span class="line"><span class="comment"># Where and how to store data.</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">dbPath:</span> <span class="string">/var/lib/mongo1</span></span><br><span class="line">  <span class="attr">journal:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#  engine:</span></span><br><span class="line"><span class="comment">#  mmapv1:</span></span><br><span class="line"><span class="comment">#  wiredTiger:</span></span><br><span class="line"><span class="comment"># how the process runs</span></span><br><span class="line"><span class="attr">processManagement:</span></span><br><span class="line">  <span class="attr">fork:</span> <span class="literal">true</span>  <span class="comment"># fork and run in background</span></span><br><span class="line">  <span class="attr">pidFilePath:</span> <span class="string">/var/run/mongodb/mongod1.pid</span>  <span class="comment"># location of pidfile</span></span><br><span class="line">  <span class="attr">timeZoneInfo:</span> <span class="string">/usr/share/zoneinfo</span></span><br><span class="line"><span class="comment"># network interfaces</span></span><br><span class="line"><span class="comment"># bindIp默认是127的，需要改成本机地址或者0.0.0.0，以远程连接，端口如果是单机部署，需要区分不同的端口</span></span><br><span class="line"><span class="attr">net:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">  <span class="attr">bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">,172.16.13.44</span>  <span class="comment"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span></span><br><span class="line"><span class="comment">#security:</span></span><br><span class="line"><span class="comment">#  authorization: enabled</span></span><br><span class="line"><span class="comment">#  keyFile: /tmp/key.file</span></span><br><span class="line"><span class="comment">#operationProfiling:</span></span><br><span class="line"><span class="comment">#打开副本集功能</span></span><br><span class="line"><span class="attr">replication:</span></span><br><span class="line">  <span class="attr">replSetName:</span> <span class="string">"rs0"</span></span><br><span class="line"><span class="comment">#sharding:</span></span><br><span class="line"><span class="comment">## Enterprise-Only Options</span></span><br><span class="line"><span class="comment">#auditLog:</span></span><br><span class="line"><span class="comment">#snmp:</span></span><br></pre></td></tr></table></figure>
<p>将mongo添加到系统服务，以便管理   ，vim /usr/lib/systemd/system/mongod1.service</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#单机部署的实例如下</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=MongoDB Database Server</span><br><span class="line">After=network.target</span><br><span class="line">Documentation=https://docs.mongodb.org/manual</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=mongod</span><br><span class="line">Group=mongod</span><br><span class="line">Environment=<span class="string">"OPTIONS=-f /etc/mongod1.conf"</span></span><br><span class="line">EnvironmentFile=-/etc/sysconfig/mongod</span><br><span class="line">ExecStart=/usr/bin/mongod <span class="variable">$OPTIONS</span></span><br><span class="line"><span class="comment">#多机部署的话，注意修改这里的配置</span></span><br><span class="line">ExecStartPre=/usr/bin/mkdir -p /var/run/mongodb1</span><br><span class="line">ExecStartPre=/usr/bin/chown mongod:mongod /var/run/mongodb1</span><br><span class="line">ExecStartPre=/usr/bin/chmod 0755 /var/run/mongodb1</span><br><span class="line">PermissionsStartOnly=<span class="literal">true</span></span><br><span class="line">PIDFile=/var/run/mongodb/mongod1.pid</span><br><span class="line">Type=forking</span><br><span class="line"><span class="comment"># file size</span></span><br><span class="line">LimitFSIZE=infinity</span><br><span class="line"><span class="comment"># cpu time</span></span><br><span class="line">LimitCPU=infinity</span><br><span class="line"><span class="comment"># virtual memory size</span></span><br><span class="line">LimitAS=infinity</span><br><span class="line"><span class="comment"># open files</span></span><br><span class="line">LimitNOFILE=64000</span><br><span class="line"><span class="comment"># processes/threads</span></span><br><span class="line">LimitNPROC=64000</span><br><span class="line"><span class="comment"># locked memory</span></span><br><span class="line">LimitMEMLOCK=infinity</span><br><span class="line"><span class="comment"># total threads (user+kernel)</span></span><br><span class="line">TasksMax=infinity</span><br><span class="line">TasksAccounting=<span class="literal">false</span></span><br><span class="line"><span class="comment"># Recommended limits for for mongod as specified in</span></span><br><span class="line"><span class="comment"># http://docs.mongodb.org/manual/reference/ulimit/#recommended-settings</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>启动服务， systemctl  start mongod。然后连接服务器，<code>mongo --port 27019</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">rs.initiate()</span><br><span class="line"><span class="comment">#添加副本集成员</span></span><br><span class="line">rs.add(<span class="string">'172.16.13.xx:27018'</span>)</span><br><span class="line"><span class="comment">#删除节点</span></span><br><span class="line">rs.remove(<span class="string">'172.16.13.xx:27018'</span>)</span><br><span class="line"><span class="comment">#故障切换，主动关闭主库</span></span><br><span class="line">use admin</span><br><span class="line">db.shutdownServer()</span><br></pre></td></tr></table></figure>
<p><a name="gykib"></a></p>
<h2 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h2><p>在生产环境，建议配置至少一个安全认证方式，我这里采用keyfile的认证方式<br>在配置文件添加安全选项配置  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个秘钥</span></span><br><span class="line"><span class="string">openssl</span> <span class="string">genrsa</span> <span class="string">-out</span> <span class="string">~/key.file</span> <span class="number">1024</span></span><br><span class="line"><span class="comment">#mongo只识别密钥，删除生成文件的首行和尾行</span></span><br><span class="line"><span class="comment">#修改权限</span></span><br><span class="line"><span class="string">chmod</span>  <span class="number">600</span> <span class="string">~/key.file&amp;&amp;chown</span>  <span class="string">mongod.mongod</span> <span class="string">/tmp/key.file</span></span><br><span class="line"><span class="comment">#新增配置</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">   <span class="attr">keyFile:</span> <span class="string">xxx.key</span></span><br><span class="line">   <span class="attr">clusterAuthMode:</span> <span class="string">keyFile</span></span><br><span class="line">   <span class="attr">authorization:</span> <span class="string">enabled</span> <span class="comment">#由于开启验证必须添加用户</span></span><br><span class="line"><span class="comment">#创建用户</span></span><br><span class="line"></span><br><span class="line"><span class="string">use</span> <span class="string">admin</span></span><br><span class="line"><span class="string">db.createUser(</span> <span class="string">&#123;user:</span> <span class="string">"cluster"</span><span class="string">,pwd:</span> <span class="string">"cluster"</span><span class="string">,roles:</span> <span class="string">[</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">"clusterAdmin"</span><span class="string">,</span> <span class="attr">db:</span> <span class="string">"admin"</span> <span class="string">&#125;</span> <span class="string">]&#125;)</span></span><br><span class="line"><span class="string">db.createUser(</span> <span class="string">&#123;user:</span> <span class="string">"admin"</span><span class="string">,pwd:</span> <span class="string">"123456"</span><span class="string">,roles:</span> <span class="string">[</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">"userAdminAnyDatabase"</span><span class="string">,</span> <span class="attr">db:</span> <span class="string">"admin"</span> <span class="string">&#125;</span> <span class="string">]&#125;)</span></span><br><span class="line"><span class="comment">#查看用户的角色和拥有的权限</span></span><br><span class="line"><span class="string">db.getUser('cluster')</span></span><br><span class="line"><span class="string">db.getRole("clusterAdmin",&#123;</span> <span class="attr">showPrivileges:</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">)</span></span><br><span class="line"><span class="comment">#授予新的角色</span></span><br><span class="line"><span class="string">use</span> <span class="string">admin</span> </span><br><span class="line"><span class="string">db.grantRolesToUser(</span></span><br><span class="line">    <span class="string">"cluster"</span><span class="string">,</span></span><br><span class="line">    <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">"clusterAdmin"</span><span class="string">,</span> <span class="attr">db:</span> <span class="string">"admin"</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="string">]</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="comment">#撤销角色</span></span><br><span class="line"><span class="string">db.revokeRolesFromUser(</span></span><br><span class="line">    <span class="string">"cluster"</span><span class="string">,</span></span><br><span class="line">    <span class="string">[</span></span><br><span class="line">      <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">"userAdminAnyDatabase"</span><span class="string">,</span> <span class="attr">db:</span> <span class="string">"admin"</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="string">]</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>mongodb使用pymongo批量插入数据</title>
    <url>/2019/06/23/yuque/mongodb%E4%BD%BF%E7%94%A8pymongo%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p><a name="GDjxS"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在测试mongo相关功能的时候，需要批量插入数据，写一个脚本来批量插入<br><a name="JZ2dp"></a></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>安装 pymongo ，直接使用pip3安装，后面使用insert_many,insert_one的时候会报错如下，是因为默认安装的版本不是最新的，旧版本不支持最新的函数，直接安装最新的，<code>pip3 install -U pymongo</code><br>但是使用系统默认的python3，运行，会遇到各种问题，因为centos7系统默认的python3的path和pip3安装的东西不匹配，所以这里我直接用<code>/usr/local/python3.6.4/bin</code>,下的执行文件，而不是系统默认的<code>/usr/bin/python3</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TypeError: <span class="string">'Collection'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable. If you meant to call the <span class="string">'insert_one'</span> method on a <span class="string">'Collection'</span> object it <span class="keyword">is</span> failing because no such method exists.</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1561264196195-837f90bf-ec0d-47d3-a8cc-a9349d883c29.png#align=left&amp;display=inline&amp;height=109&amp;name=image.png&amp;originHeight=109&amp;originWidth=1052&amp;size=15628&amp;status=done&amp;width=1052" alt="image.png"><br><a name="692dj"></a></p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="comment">#处理连接信息。建立连接</span></span><br><span class="line">auth_str=<span class="string">'cluster:cluster@'</span></span><br><span class="line">host_info=<span class="string">'172.16.13.44:27017,172.16.13.44:27018,172.16.13.44:27019'</span></span><br><span class="line">MONGODB=<span class="string">'test'</span></span><br><span class="line">param_str=<span class="string">'?authMechanism=SCRAM-SHA-1&amp;authSource=admin&amp;replicaSet=rs0'</span></span><br><span class="line">uri=<span class="string">'mongodb://%s%s/%s%s'</span> % (auth_str, host_info, MONGODB, param_str)</span><br><span class="line"><span class="comment">#print(uri)</span></span><br><span class="line">client = MongoClient(uri)</span><br><span class="line"><span class="comment">#选项数据库插入数据</span></span><br><span class="line">db=client.test</span><br><span class="line">db.test.count()</span><br><span class="line">list(db.test.find())</span><br><span class="line">result = db.test.insert_many([&#123;<span class="string">'x'</span>: i&#125; <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>)])</span><br><span class="line">result.inserted_ids</span><br><span class="line">db.test.count()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>处理api中关于operators.coreos.com的报错</title>
    <url>/2019/06/19/yuque/%E5%A4%84%E7%90%86api%E4%B8%AD%E5%85%B3%E4%BA%8Eoperators.coreos.com%E7%9A%84%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p><a name="XBquQ"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在测试环境中的监控一直报错，kubeapierrorhigh,经查看，是default，ns中存在异常的api，<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1560937510226-cd131275-7082-42dd-b667-f02416e414e9.png#align=left&amp;display=inline&amp;height=67&amp;name=image.png&amp;originHeight=67&amp;originWidth=1279&amp;size=14567&amp;status=done&amp;width=1279" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1560937744078-cef665bd-2e1e-4e8a-ba98-5560c4ea8fbd.png#align=left&amp;display=inline&amp;height=203&amp;name=image.png&amp;originHeight=203&amp;originWidth=1524&amp;size=94477&amp;status=done&amp;width=1524" alt="image.png"><br>通过<code>kubectl api-resources</code>发现该进程，已无法提供访问<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1560937667292-018e4c06-245a-4978-8fdb-d7108adcce83.png#align=left&amp;display=inline&amp;height=100&amp;name=image.png&amp;originHeight=100&amp;originWidth=1273&amp;size=16079&amp;status=done&amp;width=1273" alt="image.png"><br><a name="q1w5k"></a></p>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>删除对应的出问题的api</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl  delete  -n kube-system  delete apiservice v1.packages.operators.coreos.com</span><br></pre></td></tr></table></figure>
<p>删除对应的 api后，对应的告警没有了，至于具体这个出错的原因，始终没弄清楚，但是这个api不影响集群，所以先删除了</p>
]]></content>
  </entry>
  <entry>
    <title>mongodb副本集重新配置</title>
    <url>/2019/05/24/yuque/mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><a name="D4dM5"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最开始部署mongodb副本集的时候使用的是本地地址，导致后面使用连接工具无法远程连接，故需要修改初始化的副本集配置<br><a name="4Yw5l"></a></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; db.version();</span><br><span class="line">4.0.9</span><br><span class="line">&gt; conf=rs.conf()</span><br><span class="line">&gt; conf.members[0].host=<span class="string">"172.16.13.x:27017"</span>;</span><br><span class="line">&gt; conf.members[1].host=<span class="string">"172.16.13.x:27018"</span>;</span><br><span class="line">&gt; conf.members[2].host=<span class="string">"172.16.13.x:27019"</span>;</span><br><span class="line">&gt; rs.reconfig(conf,&#123;<span class="string">"force"</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>kubeadm安装的集群的备份和恢复实践</title>
    <url>/2019/05/16/yuque/kubeadm%E5%AE%89%E8%A3%85%E7%9A%84%E9%9B%86%E7%BE%A4%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a name="yIkUB"></a></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文档简述了Kubernetes主节点灾备恢复的相关步骤，供在发生k8s master崩溃时操作 <br><strong>环境：</strong>kubeadm安装的k8s  1.14.1<br><a name="4Pono"></a></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>查看集群的成员和现存的key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">member list</span><br><span class="line">ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">get / --prefix --keys-only</span><br></pre></td></tr></table></figure>
<p><a name="YJhdu"></a></p>
<h3 id="备份的实现和恢复"><a href="#备份的实现和恢复" class="headerlink" title="备份的实现和恢复"></a>备份的实现和恢复</h3><p>etcd集群数据备份，这里我写了一个脚本实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#脚本需要依赖etcdctl，安装  yum install etcd</span></span><br><span class="line"><span class="comment">#获取脚本所存放目录</span></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`</span><br><span class="line">bash_path=`<span class="built_in">pwd</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本名</span></span><br><span class="line">me=$(basename <span class="variable">$0</span>)</span><br><span class="line"><span class="comment"># delete dir and keep days</span></span><br><span class="line">delete_dirs=(<span class="string">"/data/backup/kubernetes:7"</span>)</span><br><span class="line">backup_dir=/data/backup/kubernetes</span><br><span class="line">files_dir=(<span class="string">"/etc/kubernetes"</span> <span class="string">"/var/lib/kubelet"</span>)</span><br><span class="line">log_dir=<span class="variable">$backup_dir</span>/<span class="built_in">log</span></span><br><span class="line">shell_log=<span class="variable">$log_dir</span>/<span class="variable">$&#123;USER&#125;</span>_<span class="variable">$&#123;me&#125;</span>.<span class="built_in">log</span></span><br><span class="line">ssh_port=<span class="string">"22"</span></span><br><span class="line">ssh_parameters=<span class="string">"-o StrictHostKeyChecking=no -o ConnectTimeout=60"</span></span><br><span class="line">ssh_command=<span class="string">"ssh <span class="variable">$&#123;ssh_parameters&#125;</span> -p <span class="variable">$&#123;ssh_port&#125;</span>"</span></span><br><span class="line">scp_command=<span class="string">"scp <span class="variable">$&#123;ssh_parameters&#125;</span> -P <span class="variable">$&#123;ssh_port&#125;</span>"</span></span><br><span class="line">DATE=$(date +%F)</span><br><span class="line">TIME=$(date <span class="string">'+%Y%m%d%H'</span>)</span><br><span class="line"></span><br><span class="line">BACK_SERVER=<span class="string">"127.0.0.1"</span>  <span class="comment"># 远程备份服务器IP</span></span><br><span class="line">BACK_SERVER_BASE_DIR=<span class="string">"/data/backup"</span></span><br><span class="line">BACK_SERVER_DIR=<span class="string">"<span class="variable">$BACK_SERVER_BASE_DIR</span>/kubernetes/<span class="variable">$&#123;HOSTNAME&#125;</span>"</span>  <span class="comment"># 远程备份服务器目录</span></span><br><span class="line">BACK_SERVER_LOG_DIR=<span class="string">"<span class="variable">$BACK_SERVER_BASE_DIR</span>/kubernetes/logs"</span></span><br><span class="line"><span class="comment">#恢复时设置，将host和name顺序对应</span></span><br><span class="line">HOSTS=(<span class="string">"127.0.0.1"</span>)</span><br><span class="line">NAME=(<span class="string">"node1"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义保存日志函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">save_log</span></span> () &#123;</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"`date +%F\ %T` $*"</span> &gt;&gt; <span class="variable">$shell_log</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">save_log <span class="string">"start backup etcd"</span></span><br><span class="line"><span class="comment">#确认日志目录</span></span><br><span class="line">[ ! -d <span class="variable">$log_dir</span> ] &amp;&amp; mkdir -p <span class="variable">$log_dir</span></span><br><span class="line"><span class="comment">#定义输出颜色函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">red_echo</span></span> () &#123;</span><br><span class="line"><span class="comment">#用法:  red_echo "内容"</span></span><br><span class="line">    <span class="built_in">local</span> what=$*</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"\e[1;31m <span class="variable">$&#123;what&#125;</span> \e[0m"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">green_echo</span></span> () &#123;</span><br><span class="line"><span class="comment">#用法:  green_echo "内容"</span></span><br><span class="line">    <span class="built_in">local</span> what=$*</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"\e[1;32m <span class="variable">$&#123;what&#125;</span> \e[0m"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">yellow_echo</span></span> () &#123;</span><br><span class="line"><span class="comment">#用法:  yellow_echo "内容"</span></span><br><span class="line">    <span class="built_in">local</span> what=$*</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"\e[1;33m <span class="variable">$&#123;what&#125;</span> \e[0m"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#备份函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">backup</span></span> () &#123;</span><br><span class="line">    <span class="keyword">for</span> f_d <span class="keyword">in</span> <span class="variable">$&#123;files_dir[@]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">        f_name=$(basename <span class="variable">$&#123;f_d&#125;</span>)</span><br><span class="line">        d_name=$(dirname <span class="variable">$f_d</span>)</span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$d_name</span></span><br><span class="line">        tar -cjf <span class="variable">$&#123;f_name&#125;</span>.tar.bz <span class="variable">$f_name</span></span><br><span class="line">        <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">            file_size=$(du <span class="variable">$&#123;f_name&#125;</span>.tar.bz|awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line">            save_log <span class="string">"<span class="variable">$file_size</span> <span class="variable">$&#123;f_name&#125;</span>.tar.bz"</span></span><br><span class="line">            save_log <span class="string">"finish tar <span class="variable">$&#123;f_name&#125;</span>.tar.bz"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            file_size=0</span><br><span class="line">            save_log <span class="string">"failed tar <span class="variable">$&#123;f_name&#125;</span>.tar.bz"</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        rsync -avzP <span class="variable">$&#123;f_name&#125;</span>.tar.bz  <span class="variable">$backup_dir</span>/<span class="variable">$&#123;TIME&#125;</span>-<span class="variable">$&#123;f_name&#125;</span>.tar.bz</span><br><span class="line">        rm -f <span class="variable">$&#123;f_name&#125;</span>.tar.bz</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line">    etcdctl --cert=/etc/kubernetes/pki/etcd/server.crt \</span><br><span class="line">        --key=/etc/kubernetes/pki/etcd/server.key \</span><br><span class="line">        --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">        snapshot save <span class="variable">$backup_dir</span>/<span class="variable">$&#123;TIME&#125;</span>-k8s-snapshot.db</span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$backup_dir</span></span><br><span class="line">    tar -cjf <span class="variable">$&#123;TIME&#125;</span>-k8s-snapshot.tar.bz <span class="variable">$&#123;TIME&#125;</span>-k8s-snapshot.db </span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        file_size=$(du <span class="variable">$&#123;TIME&#125;</span>-k8s-snapshot.tar.bz|awk <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line">        save_log <span class="string">"<span class="variable">$file_size</span> <span class="variable">$&#123;f_name&#125;</span>.tar.bz"</span></span><br><span class="line">        save_log <span class="string">"finish tar <span class="variable">$&#123;f_name&#125;</span>.tar.bz"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        file_size=0</span><br><span class="line">        save_log <span class="string">"failed tar <span class="variable">$&#123;f_name&#125;</span>.tar.bz"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    rm -f <span class="variable">$&#123;TIME&#125;</span>-k8s-snapshot.db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">rsync_backup_files</span></span> () &#123;</span><br><span class="line">    <span class="comment"># 传输日志文件</span></span><br><span class="line">    <span class="comment">#传输到远程服务器备份, 需要配置免密ssh认证</span></span><br><span class="line">    <span class="variable">$ssh_command</span> root@<span class="variable">$&#123;BACK_SERVER&#125;</span> <span class="string">"mkdir -p <span class="variable">$&#123;BACK_SERVER_DIR&#125;</span>/<span class="variable">$&#123;DATE&#125;</span>/"</span></span><br><span class="line">    rsync -avz --bwlimit=5000 -e <span class="string">"<span class="variable">$&#123;ssh_command&#125;</span>"</span> <span class="variable">$backup_dir</span>/*.bz \</span><br><span class="line">    root@<span class="variable">$&#123;BACK_SERVER&#125;</span>:<span class="variable">$&#123;BACK_SERVER_DIR&#125;</span>/<span class="variable">$&#123;DATE&#125;</span>/</span><br><span class="line">    [ $? -eq 0 ] &amp;&amp; save_log <span class="string">"success rsync"</span> || \</span><br><span class="line">      save_log <span class="string">"failed rsync"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">delete_old_files</span></span> () &#123;</span><br><span class="line">    <span class="keyword">for</span> delete_dir_keep_days <span class="keyword">in</span> <span class="variable">$&#123;delete_dirs[@]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">        delete_dir=$(<span class="built_in">echo</span> <span class="variable">$delete_dir_keep_days</span>|awk -F<span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span>)</span><br><span class="line">        keep_days=$(<span class="built_in">echo</span> <span class="variable">$delete_dir_keep_days</span>|awk -F<span class="string">':'</span> <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">        [ -n <span class="string">"<span class="variable">$delete_dir</span>"</span> ] &amp;&amp; <span class="built_in">cd</span> <span class="variable">$&#123;delete_dir&#125;</span></span><br><span class="line">        [ $? -eq 0 ] &amp;&amp; find -L <span class="variable">$&#123;delete_dir&#125;</span> -mindepth 1 -mtime +<span class="variable">$keep_days</span> -<span class="built_in">exec</span> rm -rf &#123;&#125; \;</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#恢复引导说明</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">restore_backup</span></span>()&#123;</span><br><span class="line">    len=<span class="variable">$&#123;#HOSTS[@]&#125;</span></span><br><span class="line">    <span class="keyword">for</span>((i=0;i&lt;<span class="variable">$&#123;len&#125;</span>;i++));</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        initial=<span class="variable">$&#123;initial&#125;</span>,<span class="variable">$&#123;NAME[i]&#125;</span>=https://<span class="variable">$&#123;HOSTS[i]&#125;</span>:2380</span><br><span class="line">    <span class="keyword">done</span> </span><br><span class="line">    initial=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;initial&#125;</span>"</span>|sed -r <span class="string">'s/^,//g'</span>`</span><br><span class="line">    <span class="comment">#echo "$&#123;initial&#125;"</span></span><br><span class="line">    <span class="comment">#恢复的准备工作</span></span><br><span class="line">    red_echo <span class="string">'为了确保恢复成功，请手动依次执行以下命令'</span></span><br><span class="line">    red_echo  <span class="string">'首先需要分别停掉Master机器的kube-apiserver，所有master执行以下命令,确保kube-apiserver已经停止'</span></span><br><span class="line">    yellow_echo <span class="string">'mv /etc/kubernetes/manifests /etc/kubernetes/manifests.bak'</span></span><br><span class="line">    yellow_echo  <span class="string">'docker ps | grep  -E "k8s_kube-apiserver|k8s_etcd|k8s_kube-controller|k8s_kube-scheduler"| wc -l'</span></span><br><span class="line">    red_echo    <span class="string">'备份原etcd目录'</span></span><br><span class="line">    yellow_echo <span class="string">'mv /var/lib/etcd /var/lib/etcd.bak'</span></span><br><span class="line">    red_echo    <span class="string">'etcd集群用同一份snapshot恢复'</span></span><br><span class="line">    green_echo  <span class="string">'本地已经存在的备份如下：'</span></span><br><span class="line">    ls <span class="variable">$backup_dir</span> | grep <span class="string">"snapshot"</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">"选择要恢复的备份(xxx.tar.bz)："</span> snapshot</span><br><span class="line">    <span class="built_in">cd</span> /tmp</span><br><span class="line">    dbfile=`tar -jxvf <span class="variable">$backup_dir</span>/<span class="variable">$snapshot</span>`</span><br><span class="line">    green_echo <span class="string">'即将恢复的备份为： '</span><span class="variable">$dbfile</span><span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span>  host <span class="keyword">in</span> <span class="variable">$&#123;HOSTS[@]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="comment">#准备恢复文件</span></span><br><span class="line">        green_echo <span class="string">"开始发送备份文件到 <span class="variable">$&#123;host&#125;</span>上"</span></span><br><span class="line">        rsync -avz /tmp/<span class="variable">$dbfile</span> <span class="variable">$host</span>:/tmp/</span><br><span class="line">        green_echo <span class="string">"在 <span class="variable">$&#123;host&#125;</span>上执行"</span></span><br><span class="line">        <span class="comment">#打印需要手动执行的命令</span></span><br><span class="line">        yellow_echo <span class="string">'  cd /tmp/</span></span><br><span class="line"><span class="string">    export ETCDCTL_API=3</span></span><br><span class="line"><span class="string">    '</span>etcdctl snapshot restore <span class="variable">$dbfile</span><span class="string">' \</span></span><br><span class="line"><span class="string">    '</span>--endpoints=<span class="variable">$&#123;host&#125;</span>:2379<span class="string">' \</span></span><br><span class="line"><span class="string">    --name=$HOSTNAME \</span></span><br><span class="line"><span class="string">    --cert=/etc/kubernetes/pki/etcd/server.crt \</span></span><br><span class="line"><span class="string">    --key=/etc/kubernetes/pki/etcd/server.key \</span></span><br><span class="line"><span class="string">    --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span></span><br><span class="line"><span class="string">    '</span>--initial-advertise-peer-urls=https://<span class="variable">$&#123;host&#125;</span>:2380<span class="string">' \</span></span><br><span class="line"><span class="string">    --initial-cluster-token=etcd-cluster-0 \</span></span><br><span class="line"><span class="string">    --initial-cluster='</span><span class="variable">$&#123;initial&#125;</span><span class="string">' \</span></span><br><span class="line"><span class="string">    --data-dir=/var/lib/etcd'</span> </span><br><span class="line">    <span class="keyword">done</span>  </span><br><span class="line">    red_echo <span class="string">'全部恢复完成后，所有Master机器恢复manifests'</span>  </span><br><span class="line">    yellow_echo <span class="string">'mv /etc/kubernetes/manifests.bak /etc/kubernetes/manifests'</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#backup</span></span><br><span class="line"><span class="comment">#delete_old_files</span></span><br><span class="line"><span class="comment">#远程备份</span></span><br><span class="line"><span class="comment">#rsync_backup_files</span></span><br><span class="line"><span class="comment">#数据恢复</span></span><br><span class="line"><span class="comment">#restore_backup</span></span><br><span class="line"><span class="function"><span class="title">echo_help</span></span>() &#123;</span><br><span class="line">red_echo  <span class="string">"  <span class="variable">$(basename $0)</span>:"</span></span><br><span class="line">    red_echo  <span class="string">"b|backup:          创建备份"</span></span><br><span class="line">    red_echo  <span class="string">"r|restore:         恢复备份"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ -z <span class="string">"<span class="variable">$&#123;ACTION&#125;</span>"</span> ] &amp;&amp; ACTION=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;ACTION&#125;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">'b'</span>|<span class="string">'backup'</span>)&#123; backup; &#125;;;</span><br><span class="line">    <span class="string">'r'</span>|<span class="string">'retore'</span>)&#123; restore_backup; &#125;;;</span><br><span class="line">    *)&#123; echo_help; &#125;;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line">save_log <span class="string">"finish <span class="variable">$0</span>\n"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p><a name="R6CFX"></a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一般来说，如果master节点需要备份恢复，那除了误操作和删除，很可能就是整个机器已出现了故障，因此需要进行etcd数据的恢复，而在恢复时，有个前提条件，就是在待恢复的机器上，机器名称和ip地址需要与崩溃前的master节点配置完全一样，因为这个配置是写进了etcd数据存储当中的。<br><a name="Ew4Ss"></a></p>
<h3 id="主节点数据备份"><a href="#主节点数据备份" class="headerlink" title="主节点数据备份"></a>主节点数据备份</h3><ol>
<li>/etc/kubernetes/目录下的所有文件(证书，manifest文件)</li>
<li>用户主目录下.kube/config文件(kubectl连接认证)</li>
<li><p>/var/lib/kubelet/目录下所有文件(plugins容器连接认证)<br><a name="XhGdL"></a></p>
<h3 id="主节点组件恢复"><a href="#主节点组件恢复" class="headerlink" title="主节点组件恢复"></a>主节点组件恢复</h3></li>
<li><p>按之前的安装脚本进行全新安装(kubeadm reset，iptables –X…)</p>
</li>
<li>停止系统服务systemctl stop kubelet.service。</li>
<li>删除相关插件容器(coredns,flannel,dashboard)。</li>
<li>恢复etcd数据(参见第一章节操作)。</li>
<li>将之前备份的三个目录依次还原。</li>
<li>重启系统服务systemctl start kubelet.service。</li>
<li>一杯咖啡，稍等片刻，待所有组件启动成功后进行验证。</li>
</ol>
<p>参考：<br><a href="https://yq.aliyun.com/articles/561894" target="_blank" rel="noopener">Kubernetes Master节点 灾备恢复操作指南</a></p>
]]></content>
  </entry>
  <entry>
    <title>通过域控下发软件安装过程</title>
    <url>/2019/05/13/yuque/%E9%80%9A%E8%BF%87%E5%9F%9F%E6%8E%A7%E4%B8%8B%E5%8F%91%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><a name="XyJFm"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>出于安全考虑，在域中的服务器需要批量安装某软件。<br><a name="Il708"></a></p>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>脚本如下  </p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line"><span class="keyword">Set</span> <span class="keyword">Of</span> = CreateObject(<span class="string">"Scripting.FileSystemObject"</span>) </span><br><span class="line"><span class="keyword">Set</span> objShell = CreateObject(<span class="string">"Shell.Application"</span>)</span><br><span class="line"><span class="keyword">dim</span> OK,oShell </span><br><span class="line">OK=<span class="literal">False</span></span><br><span class="line"><span class="keyword">set</span> bag=getobject(<span class="string">"winmgmts:\\.\root\cimv2"</span>) </span><br><span class="line"><span class="keyword">set</span> pipe=bag.execquery(<span class="string">"select * from win32_process where name='xxx.exe'"</span>) </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> match <span class="keyword">in</span> pipe</span><br><span class="line">OK = <span class="literal">True</span> </span><br><span class="line">msgbox <span class="string">"xxx.exe正在运行。。。"</span></span><br><span class="line">WScript.Quit</span><br><span class="line"><span class="keyword">Next</span></span><br><span class="line"><span class="keyword">If</span> <span class="keyword">not</span> OK <span class="keyword">Then</span> </span><br><span class="line">msgbox <span class="string">"xxx.exe没有运行！"</span></span><br><span class="line"><span class="keyword">Set</span> objShell = CreateObject(<span class="string">"Wscript.Shell"</span>)</span><br><span class="line">WScript.Sleep <span class="number">1000</span></span><br><span class="line">msgbox <span class="string">"请手动完成xx客户端的安装，否则每次开机都提示"</span>,<span class="number">0</span></span><br><span class="line">            strCommandLine = <span class="string">"\\chinawyny.com\SysVol\domain.com\Policies\&#123;5A850BAF-1901-4071-AD41-1AF69B9BEAA8&#125;\User\Scripts\Logon\DSMClientSetup.exe"</span></span><br><span class="line">objShell.Run(strCommandLine)</span><br><span class="line"><span class="keyword">set</span> WshShell = CreateObject(<span class="string">"WScript.Shell"</span>)</span><br><span class="line">WScript.Sleep <span class="number">1000</span></span><br><span class="line">msgbox <span class="string">"要显示的内容"</span>,<span class="number">0</span> </span><br><span class="line">WScript.Quit</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span> </span><br><span class="line"><span class="keyword">loop</span></span><br></pre></td></tr></table></figure>
<p>这里首先检测目标主机上是否安装了对应的程序并且已经自启动，如果已经启动，则提示软件已经在运行，如果没有运行则提示需要安装，如果是静默安装包，还可以实现静默安装，不弹出setup的安装步骤。软件的安装文件 路径为，域控服务器上的指定地址。  <br>然后编辑域控的策略，添加该脚本即可  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1557711332123-62806fa6-e89e-4fe6-8ec3-edef1bf9edaa.png#align=left&amp;display=inline&amp;height=570&amp;name=image.png&amp;originHeight=570&amp;originWidth=808&amp;size=49605&amp;status=done&amp;width=808" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL基于GTID复制的实践</title>
    <url>/2019/04/24/yuque/MySQL%E5%9F%BA%E4%BA%8EGTID%E5%A4%8D%E5%88%B6%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a name="61a3ec66"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GTID(Global Transaction ID)是MySQL5.6引入的功能，可以在集群全局范围标识事务，用于取代过去通过binlog文件偏移量定位复制位置的传统方式。借助GTID，在发生主备切换的情况下，MySQL的其它Slave可以自动在新主上找到正确的复制位置，这大大简化了复杂复制拓扑下集群的维护，也减少了人为设置复制位置发生误操作的风险。另外，基于GTID的复制可以忽略已经执行过的事务,减少了数据发生不一致的风险。<br><a name="224e2ccd"></a></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">enforce_gtid_consistency = ON</span><br><span class="line">gtid_mode = ON</span><br><span class="line">server_id = 9910</span><br><span class="line">binlog_format = row</span><br></pre></td></tr></table></figure>
<p>同时主备库都开启binlog如果不设置级联从库，从库不要设置log_slave_updates参数。<br>这是最合理的设置。<br><strong>建立复制用户</strong>  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#新版本中建立用户和授权需要分开执行</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'hh'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'hh'</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'hh'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>导出主库数据</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump  -uroot -proot -h127.0.0.1 --single-transaction  --master-data=2  -R -E --triggers  --all-databases &gt; test.sql</span><br></pre></td></tr></table></figure></p>
<p><strong>在从库source备份</strong>，然后使用MASTER_AUTO_POSITION建立同步<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> </span><br><span class="line">master_host=<span class="string">'xxx'</span>,</span><br><span class="line">master_user=<span class="string">'repl'</span>,</span><br><span class="line">master_password=<span class="string">'repl'</span>,</span><br><span class="line">master_port=<span class="number">3306</span>,</span><br><span class="line">MASTER_AUTO_POSITION = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>启动slave </strong><br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span></span><br></pre></td></tr></table></figure></p>
<p><a name="184c7298"></a></p>
<h2 id="如何修复复制错误"><a href="#如何修复复制错误" class="headerlink" title="如何修复复制错误"></a>如何修复复制错误</h2><p>在基于GTID的复制拓扑中，要想修复Slave的SQL线程错误，过去的SQL_SLAVE_SKIP_COUNTER方式不再适用。需要通过设置gtid_next或gtid_purged完成，当然前提是已经确保主从数据一致，仅仅需要跳过复制错误让复制继续下去。比如下面的场景：  </p>
<p>在从库上创建表tb1  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; set sql_log_bin=0;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; create table tb1(id int primary key,c1 int);</span><br><span class="line">Query OK, 0 rows affected (1.06 sec)</span><br><span class="line">mysql&gt; set sql_log_bin=1;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>在主库上创建表tb1  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table tb1(id int primary key,c1 int);</span><br><span class="line">Query OK, 0 rows affected (1.06 sec)</span><br></pre></td></tr></table></figure>
<p>由于从库上这个表已经存在，从库的复制SQL线程出错停止  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: xxx</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: binlog.000001</span><br><span class="line">          Read_Master_Log_Pos: 1422</span><br><span class="line">               Relay_Log_File: mysqld-relay-bin.000003</span><br><span class="line">                Relay_Log_Pos: 563</span><br><span class="line">        Relay_Master_Log_File: binlog.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: No</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 1050</span><br><span class="line">                   Last_Error: Error 'Table 'tb1' already exists' on query. Default database: 'test'. Query: '<span class="keyword">create</span> <span class="keyword">table</span> tb1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,c1 <span class="built_in">int</span>)<span class="string">'</span></span><br><span class="line"><span class="string">                 Skip_Counter: 0</span></span><br><span class="line"><span class="string">          Exec_Master_Log_Pos: 1257</span></span><br><span class="line"><span class="string">              Relay_Log_Space: 933</span></span><br><span class="line"><span class="string">              Until_Condition: None</span></span><br><span class="line"><span class="string">               Until_Log_File: </span></span><br><span class="line"><span class="string">                Until_Log_Pos: 0</span></span><br><span class="line"><span class="string">           Master_SSL_Allowed: No</span></span><br><span class="line"><span class="string">           Master_SSL_CA_File: </span></span><br><span class="line"><span class="string">           Master_SSL_CA_Path: </span></span><br><span class="line"><span class="string">              Master_SSL_Cert: </span></span><br><span class="line"><span class="string">            Master_SSL_Cipher: </span></span><br><span class="line"><span class="string">               Master_SSL_Key: </span></span><br><span class="line"><span class="string">        Seconds_Behind_Master: NULL</span></span><br><span class="line"><span class="string">Master_SSL_Verify_Server_Cert: No</span></span><br><span class="line"><span class="string">                Last_IO_Errno: 0</span></span><br><span class="line"><span class="string">                Last_IO_Error: </span></span><br><span class="line"><span class="string">               Last_SQL_Errno: 1050</span></span><br><span class="line"><span class="string">               Last_SQL_Error: Error '</span><span class="keyword">Table</span> <span class="string">'tb1'</span> already <span class="keyword">exists</span><span class="string">' on query. Default database: '</span><span class="keyword">test</span><span class="string">'. Query: '</span><span class="keyword">create</span> <span class="keyword">table</span> tb1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,c1 <span class="built_in">int</span>)<span class="string">'</span></span><br><span class="line"><span class="string">  Replicate_Ignore_Server_Ids: </span></span><br><span class="line"><span class="string">             Master_Server_Id: 1</span></span><br><span class="line"><span class="string">                  Master_UUID: e10c75be-5c1b-11e6-ab7c-000c296078ae</span></span><br><span class="line"><span class="string">             Master_Info_File: mysql.slave_master_info</span></span><br><span class="line"><span class="string">                    SQL_Delay: 0</span></span><br><span class="line"><span class="string">          SQL_Remaining_Delay: NULL</span></span><br><span class="line"><span class="string">      Slave_SQL_Running_State: </span></span><br><span class="line"><span class="string">           Master_Retry_Count: 86400</span></span><br><span class="line"><span class="string">                  Master_Bind: </span></span><br><span class="line"><span class="string">      Last_IO_Error_Timestamp: </span></span><br><span class="line"><span class="string">     Last_SQL_Error_Timestamp: 161203 15:14:17</span></span><br><span class="line"><span class="string">               Master_SSL_Crl: </span></span><br><span class="line"><span class="string">           Master_SSL_Crlpath: </span></span><br><span class="line"><span class="string">           Retrieved_Gtid_Set: e10c75be-5c1b-11e6-ab7c-000c296078ae:5-6</span></span><br><span class="line"><span class="string">            Executed_Gtid_Set: e10c75be-5c1b-11e6-ab7c-000c296078ae:1-5</span></span><br><span class="line"><span class="string">                Auto_Position: 1</span></span><br><span class="line"><span class="string">1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>
<p>从上面的输出可以知道，从库已经执行过的事务是’e10c75be-5c1b-11e6-ab7c-000c296078ae:1-5’,执行出错的事务是’e10c75be-5c1b-11e6-ab7c-000c296078ae:6’，当前主备的数据其实是一致的，可以通过设置gtid_next跳过这个出错的事务。 <br>在从库上执行以下语句：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; set gtid_next='e10c75be-5c1b-11e6-ab7c-000c296078ae:6';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set gtid_next='AUTOMATIC';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>K8S的污点（Taints ）和容忍（Tolerations）</title>
    <url>/2019/04/24/yuque/K8S%E7%9A%84%E6%B1%A1%E7%82%B9%EF%BC%88Taints%20%EF%BC%89%E5%92%8C%E5%AE%B9%E5%BF%8D%EF%BC%88Tolerations%EF%BC%89/</url>
    <content><![CDATA[<p>节点亲和性是pod的一个属性，它将它们_吸引_到一组节点（作为首选项或硬性要求），Taints 是与之相反的，它允许节点驱逐或抵制一个pod  <br>污点和容忍一起工作以确保不将pod安排到不适当的节点上。 将一个或多个污点应用于节点; 这标志着节点不应该接受任何不能容忍污点的pod。 容忍应用于容器，并允许（但不要求）容器安排到具有匹配的污点的节点上。<br><a name="b59c9e0f"></a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>使用<code>kubectl taints</code>为节点添加污点。例如<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes node1 key=value:NoSchedule</span><br></pre></td></tr></table></figure></p>
<p>在节点node1上放置污点。污点具有键<strong>key</strong>，值<strong>value</strong>和污点效果 <strong>NoSchedule</strong>。这意味着没有pod将能够调度到node1上，除非与pod具有匹配的容忍度。要删除上面命令添加的污点，您可以运行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes node1 key:NoSchedule-</span><br></pre></td></tr></table></figure></p>
<p>在PodSpec中指定容器的容忍Tolerations。以下两种容忍度都“匹配”上面的kubectl污染线所产生的污点，因此具有任何容忍度的容器将能够安排到node1上：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"key"</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">"value"</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"key"</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br></pre></td></tr></table></figure>
<p>如果<strong>key</strong>是相同的并且<strong>effect</strong>相同，则容忍和污点匹配，并且：  </p>
<ul>
<li><strong>operator</strong>是<strong>Exists</strong>（在这种情况下不应指定<strong>key</strong>），或  </li>
<li><strong>operator</strong>是<strong>Equal</strong>，值相等  </li>
</ul>
<p>如果未指定，则<strong>operator</strong>默认为<strong>Equal</strong>。  <br><strong>两种特殊情况：  </strong></p>
<ul>
<li><p>带有<strong>operator   Exists</strong>的空键匹配所有<strong>key</strong>，<strong>value</strong>和<strong>effect</strong>，这意味着它将容忍所有内容。 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>空<strong>effect</strong>使用<strong>key:key</strong>匹配所有<strong>effect</strong>。  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"key"</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">"Exists"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的例子使用了<strong>NoSchedule</strong>的<strong>effect</strong>。或者，您可以使用PreferNoSchedule的效果。这是NoSchedule的“首选”或“软”版本 - 系统将尽量避免放置不能容忍节点上污点的pod，但这不是必需的。第三种效果是NoExecute，稍后描述。  <br>您可以在同一节点上放置多个污点，并在同一个pod上放置多个容差。Kubernetes处理多个污点和容忍的方式就像一个过滤器：从所有节点的污点开始，然后忽略pod具有匹配容忍度的那些;剩下的未被忽视的污点对吊舱有明显的影响。特别是  </p>
<ul>
<li>如果至少有一个未被忽略的污点具有效果<strong>NoSchedule</strong>，那么Kubernetes将不会将pod安排到该节点上  </li>
<li>如果没有未被忽略的污点，效果NoSchedule，但至少有一个未被忽略的污点有效PreferNoSchedule然后Kubernetes将尝试不将pod安排到节点  </li>
<li>如果存在至少一个具有effect<strong> </strong> <strong>NoExecute</strong>的未被忽略的污点，则该pod将从该节点逐出（如果它已经在该节点上运行），并且将不会被调度到该节点上（如果它尚未在该节点上运行）。   </li>
</ul>
<p>例如，假设您的节点有这样的污点：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes node1 key1=value1:NoSchedule</span><br><span class="line">kubectl taint nodes node1 key1=value1:NoExecute</span><br><span class="line">kubectl taint nodes node1 key2=value2:NoSchedule</span><br></pre></td></tr></table></figure></p>
<p>pod有两种容忍度：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"key1"</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">"value1"</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"key1"</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">"value1"</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，pod将无法安排到节点上，因为没有容忍匹配第三种污点。但是，如果在添加污点时pod已经在节点上运行，它将能够继续运行，因为第三种污点是容器中不能容忍的三种污染中唯一的一种。（pod可以容忍node1有污点 key1=value1:NoSchedule和key1=value1:NoExecute，但是不容忍key2=value2:NoSchedule，但是key2的effect为<strong>NoSchedule，</strong>意味着在添加污点的时候如果pod已经在该node运行，则不采取处理。如果没有在该node运行，将不会调度到该节点。如果污点 key2=value2:NoExecute，pod容忍不变，那么即使已经在该node运行，添加了该污点后，pod也会被驱逐）  <br>通常情况下，如果将一个带有<strong>NoExecute</strong>效果的污点添加到一个节点，那么任何不能容忍污染的pod都会立即被驱逐，任何容忍污染的<strong>pod</strong>都不会被驱逐。但是，对<strong>NoExecute</strong>效果的容忍可以指定一个可选的<strong>tolerationSeconds</strong>字段，该字段指示在添加污点后pod将保持绑定到节点的时间。例如，<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"key1"</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">"value1"</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">"NoExecute"</span></span><br><span class="line">  <span class="attr">tolerationSeconds:</span> <span class="number">3600</span></span><br></pre></td></tr></table></figure></p>
<p>意味着如果此pod正在运行并且将匹配的污点添加到节点，则pod将保持绑定到该节点3600秒，然后被逐出。如果在此之前删除了污点，则不会驱逐pod。  <br>另外一个pod会被默认添加一个<strong>Tolerations</strong>：  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1556422394766-6c8263f4-1775-451d-95ba-d8bdd86be324.png#align=left&amp;display=inline&amp;height=74&amp;name=image.png&amp;originHeight=74&amp;originWidth=586&amp;size=8031&amp;status=done&amp;width=586" alt="image.png"><br>以上的<strong>Tolerations</strong>意味着：如果node的状态处于not_ready状态超过5分钟，那么该pod将不能在node上继续执行，将被驱逐。 <br>附注：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubernetes节点失效后pod的调度过程</span><br><span class="line">1.Master每隔一段时间和node联系一次，判定node是否失联，这个时间周期配置项为 node-monitor-period ，默认5s</span><br><span class="line">2.当node失联后一段时间后，kubernetes判定node为notready状态，这段时长的配置项为 node-monitor-grace-period ，默认40s</span><br><span class="line">3.当node失联后一段时间后，kubernetes判定node为unhealthy，这段时长的配置项为 node-startup-grace-period ，默认1m0s</span><br><span class="line">4.当node失联后一段时间后，kubernetes开始删除原node上的pod，这段时长配置项为 pod-eviction-timeout ，默认5m0s</span><br><span class="line">在应用中，想要缩短pod的重启时间，可以修改上述几个参数</span><br></pre></td></tr></table></figure>
<p><a name="OkTvs"></a></p>
<h2 id="基于污点的驱逐"><a href="#基于污点的驱逐" class="headerlink" title="基于污点的驱逐"></a>基于污点的驱逐</h2><p>之前我们提到过NoExecute污染效果，它会影响已经在节点上运行的pod，如下所示  </p>
<ul>
<li>不能容忍污染的pod立即被驱逐  </li>
<li>容忍污点而没有在容忍规范中指定tolerationSeconds的pod仍然被绑定到该节点的（如ds）  </li>
<li>容忍具有指定容忍度的污点的容器在指定的时间内保持绑定  </li>
</ul>
<p>此外，Kubernetes 1.6引入了alpha支持来表示节点问题。换句话说，当某些条件为真时，节点控制器自动污染节点。内置以下污点：  </p>
<ul>
<li><strong>node.kubernetes.io/not-ready：</strong>节点尚未就绪。这对应于NodeCondition Ready为“False”。</li>
<li><strong>node.kubernetes.io/unreachable：</strong>节点控制器无法访问节点。这对应于NodeCondition Ready为“Unknown”。  </li>
<li><strong>node.kubernetes.io/out-of-disk：</strong>节点变得磁盘不足</li>
<li><strong>node.kubernetes.io/memory-pressure：</strong>节点有内存压力</li>
<li><strong>node.kubernetes.io/disk-pressure：</strong>节点有磁盘压力</li>
<li><strong>node.kubernetes.io/network-unavailable：</strong>节点的网络不可用</li>
<li><strong>node.kubernetes.io/unschedulable：</strong>节点是不可调度的</li>
<li><strong>node.cloudprovider.kubernetes.io/uninitialized：</strong>当使用“外部”云提供程序启动kubelet时，会在节点上设置此污点以将其标记为不可用。在cloud-controller-manager的控制器初始化此节点后，kubelet将删除此污点。</li>
</ul>
<p>在版本1.13中，<strong>TaintBasedEvictions</strong>功能被提升为beta并默认启用，因此NodeController（或kubelet）会自动添加taints，并且禁用基于Ready NodeCondition从节点驱逐pod的常规逻辑。  </p>
]]></content>
  </entry>
  <entry>
    <title>基于kubeadm搭建的etcd集群的运维实践</title>
    <url>/2019/04/15/yuque/%E5%9F%BA%E4%BA%8Ekubeadm%E6%90%AD%E5%BB%BA%E7%9A%84etcd%E9%9B%86%E7%BE%A4%E7%9A%84%E8%BF%90%E7%BB%B4%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a name="a5444275"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>kubeadm提供了两种高可用方案，用户搭建k8s的高可用环境，详细对比可参考：  <br><a href="https://kubernetes.io/docs/setup/independent/ha-topology/" target="_blank" rel="noopener">Options for Highly Available Topology</a><br><a name="06f374f6"></a></p>
<h3 id="堆叠的etcd拓扑"><a href="#堆叠的etcd拓扑" class="headerlink" title="堆叠的etcd拓扑"></a>堆叠的etcd拓扑</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/svg/148941/1555317891721-1bf77d13-db55-47ba-a086-518417d0e814.svg#align=left&amp;display=inline&amp;height=560&amp;originHeight=150&amp;originWidth=200&amp;size=0&amp;status=done&amp;width=746" alt><br>特点：</p>
<ol>
<li>etcd节点和apiserver以及scheduler，controller-manager共存，需要较小的服务器资源  </li>
<li>如果node出现问题，那么master节点和etcd节点都将下线</li>
<li>这是kubeadm中的默认拓扑。使用kubeadm init和kubeadm join时使用 experimental-control-plane 作为master 加入集群时候，在控制平面节点上自动创建本地etcd成员</li>
</ol>
<p><a name="7268b27c"></a></p>
<h3 id="外部etcd集群"><a href="#外部etcd集群" class="headerlink" title="外部etcd集群"></a>外部etcd集群</h3><p><img src="https://cdn.nlark.com/yuque/0/2019/svg/148941/1555318229820-9973d48d-7e5e-4a11-9f7f-45a866df2f5f.svg#align=left&amp;display=inline&amp;height=560&amp;originHeight=150&amp;originWidth=200&amp;size=0&amp;status=done&amp;width=746" alt><br>特点：</p>
<ol>
<li>需要额外的服务器搭建etcd集群，相对于堆叠型拓扑，需要双倍的服务器节点</li>
<li>etcd节点和master分离，不像堆叠型拓扑，master或者etcd节点宕机影响更小<br><a name="0dfbe902"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#etcd需要在etcd的pod内执行</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it -n kube-system etcd-kube-node1  sh</span><br><span class="line"><span class="comment">#查看集群成员</span></span><br><span class="line">ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">member list</span><br><span class="line"><span class="comment">#健康检查</span></span><br><span class="line">ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">--endpoints=https://ip1:2379,https://ip2:2379,\</span><br><span class="line">https://ip3:2379 \</span><br><span class="line">endpoint health</span><br><span class="line"><span class="comment">#删除成员</span></span><br><span class="line">ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">member remove  [member ID]</span><br><span class="line"><span class="comment">#添加一个值  </span></span><br><span class="line">ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">put  hi  ha</span><br><span class="line"><span class="comment">#k8s删除一个节点  </span></span><br><span class="line">kubectl delete  node kube-node3  <span class="comment"># 但是不是删除etcd  member ，需要使用etcd的member remove  </span></span><br><span class="line"><span class="comment">#k8s添加节点  </span></span><br><span class="line">kubeadm join &#123;IP&#125;:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 --experimental-control-plane --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07</span><br><span class="line"><span class="comment">##参数说明</span></span><br><span class="line">--experimental-control-plane 参数，使节点作为master加入  </span><br><span class="line">--certificate-key &#123;TOKEN&#125;  自动从初始化节点下载相关证书到本地，如果没有记住，使用如下命令再次生成，有效期2小时  </span><br><span class="line">kubeadm init phase upload-certs --experimental-upload-certs</span><br></pre></td></tr></table></figure>
<p><a name="728e4049"></a></p>
<h2 id="故障演练"><a href="#故障演练" class="headerlink" title="故障演练"></a>故障演练</h2><p>故障演练，模拟在默认的堆叠模式拓扑下的故障恢复能力，大致流程，put一个值-&gt;删除一个node，同时删除该node下的etcd member -&gt;查看刚刚put值是否正常<br><a name="cae87fd3"></a></p>
<h3 id="故障模拟"><a href="#故障模拟" class="headerlink" title="故障模拟"></a>故障模拟</h3><p>添加一对key  value ，命令参考常用命令<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1555319146769-48010530-71ae-4668-b886-16a02db68b4b.png#align=left&amp;display=inline&amp;height=237&amp;name=image.png&amp;originHeight=237&amp;originWidth=793&amp;size=22829&amp;status=done&amp;width=793" alt="image.png"><br>删除一个节点，并且删除该节点的etcd  member  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1555319278519-05f33390-e506-4f98-85ec-e4d4baecb777.png#align=left&amp;display=inline&amp;height=271&amp;name=image.png&amp;originHeight=271&amp;originWidth=827&amp;size=41845&amp;status=done&amp;width=827" alt="image.png"><br>确保删除干净一点，把这个删除的节点的k8s信息和etcd的数据完全删除，在kube-node3上面执行  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm  -rf /etc/kubernetes  &amp;&amp; rm -rf /var/lib/etcd</span><br></pre></td></tr></table></figure>
<p>先查看下只有两个etcd  member的时候刚刚的数据还在不在  <br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1555319718060-cd4376fd-8f52-401c-b82a-06decf45c46b.png#align=left&amp;display=inline&amp;height=244&amp;name=image.png&amp;originHeight=244&amp;originWidth=872&amp;size=28995&amp;status=done&amp;width=872" alt="image.png"><br>确认两个etcdmember的时候数据正常<br><a name="768da49e"></a></p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>添加已经删除的节点  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm join xx:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 --experimental-control-plane --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07</span><br></pre></td></tr></table></figure>
<p>查看新加入的member，确认key  value 是否正常<br><br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1555320203871-eb9ebbdd-1012-4176-8a42-9d31ddd16b86.png#align=left&amp;display=inline&amp;height=250&amp;name=image.png&amp;originHeight=250&amp;originWidth=785&amp;size=31673&amp;status=done&amp;width=785" alt="image.png"></p>
<p>etcd集群正常，故障正常恢复</p>
]]></content>
  </entry>
  <entry>
    <title>快速批量删除pod</title>
    <url>/2019/04/13/yuque/%E5%BF%AB%E9%80%9F%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4pod/</url>
    <content><![CDATA[<p><a name="a5444275"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>因为宿主机资源关系，产生了较多被驱逐的pod，如果不清除，将会一直显示，即使pod已经被重新调度<br><a name="9bf31f74"></a></p>
<h2 id="如何删除"><a href="#如何删除" class="headerlink" title="如何删除"></a>如何删除</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除默认ns下的被驱逐的pod</span></span><br><span class="line">kubectl get pods | grep Evicted | awk <span class="string">'&#123;print $1&#125;'</span> | xargs kubectl delete pod</span><br><span class="line"><span class="comment">#删除指定空间下被驱逐的pod</span></span><br><span class="line">kubectl get pods -n kube-system | grep Evicted | awk <span class="string">'&#123;print $1&#125;'</span> | xargs kubectl delete pod -n kube-system</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>LVM扩容实践</title>
    <url>/2019/04/13/yuque/LVM%E6%89%A9%E5%AE%B9%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a name="8e1b944f"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在虚拟化平台上，为了方便资源分配，磁盘和内存都是按需分配的，内存分配后可以直接生效，磁盘扩容需要配置一定的操作实现扩容lvm<br><a name="d670ffb3"></a></p>
<h2 id="LVM介绍"><a href="#LVM介绍" class="headerlink" title="LVM介绍"></a>LVM介绍</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/148941/1555136109755-63399b13-90e0-4699-9bb4-ca353b57f92c.jpeg#align=left&amp;display=inline&amp;height=360&amp;originHeight=360&amp;originWidth=640&amp;size=0&amp;status=done&amp;width=640" alt><br>图中顶部，首先是实际的物理磁盘及其划分的分区和其上的物理卷（PV）。一个或多个物理卷可以用来创建卷组（VG）。然后基于卷组可以创建逻辑卷（LV）。只要在卷组中有可用空间，就可以随心所欲的创建逻辑卷。文件系统就是在逻辑卷上创建的，然后可以在操作系统挂载和访问。<br><a name="beea37f6"></a></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>传统的LVM扩容方法，是通过添加新的磁盘或者磁盘分区来建立新的PV，再将PV加入到VG中，从而扩大VG空间，再对相关的LV进行扩容，最后增加文件系统空间完成整个扩容工作。这种方法比较适合使用本地存储的物理机，因为磁盘空间都是固定的，只能通过增加硬盘来增加磁盘空间，这种方法可以在线完成，无需停机重启。但扩容多次后，VG中会存在多个PV，磁盘逻辑结构变得复杂，容易增加日后维护存储和磁盘分区布局的难度  </p>
<p>添加硬盘-&gt;将新硬盘做成pv-&gt;将pv加入vg-&gt;让lv使用vg新增的空间-&gt;刷新文件系统，使得lv的扩容生效  <br>具体操作如下<br><a name="59639645"></a></p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.查看分区分区                                                </span></span><br><span class="line">fdisk -l</span><br><span class="line"><span class="comment">#2.创建物理卷 </span></span><br><span class="line">pvcreat /dev/sdb1</span><br><span class="line"><span class="comment">#3.查看卷组名称及使用情况</span></span><br><span class="line">vgdisplay</span><br><span class="line"><span class="comment">#4.将物理卷扩展到卷组  </span></span><br><span class="line">vgextend centos /dev/sdb   (此处‘centos’是卷组名称)</span><br><span class="line"><span class="comment">#5.查看要扩展的逻辑卷  </span></span><br><span class="line">lvdisplay   <span class="comment">#得到要扩展的lv为  /dev/centos/root</span></span><br><span class="line"><span class="comment">#6.将卷组中空闲空间扩展到 /         </span></span><br><span class="line"><span class="comment">#lvextend -l +100%FREE /dev/centos/root</span></span><br><span class="line">6.刷新文件系统是扩容生效，根据文件系统的不同命令不同 df -hT 查看文件系统类型  </span><br><span class="line"><span class="comment">#ext4使用如下命令</span></span><br><span class="line">e2fsck -f /dev/centos/root</span><br><span class="line">resize2fs /dev/centos/root</span><br><span class="line"><span class="comment">#xfs使用如下命令  </span></span><br><span class="line">xfs_growfs  /dev/centos/root</span><br></pre></td></tr></table></figure>
<p><a name="d3a3f2e4"></a></p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>在方案一上面的改变是，不直接增加新的硬盘；由于在虚拟化环境中可以直接增加磁盘容量，所以这里选择直接增加磁盘容量，而不是添加硬盘，个人认为在虚拟化环境下更方便管理  <br>修改原硬盘大小-&gt;在原磁盘新建分区-&gt;将新分区做成pv-&gt;将pv加入vg-&gt;让lv使用vg新增的空间-&gt;刷新文件系统，使得lv的扩容生效<br>具体操作如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1.直接编辑虚拟机资源，在原硬盘上，修改硬盘容量到目标值                                                </span><br><span class="line">#2.重新扫描硬件，使系统识别到变化 </span><br><span class="line">echo &apos;1&apos; &gt; /sys/class/scsi_disk/0\:0\:0\:0/device/rescan </span><br><span class="line">echo &apos;1&apos; &gt; /sys/class/scsi_disk/0\:0\:1\:0/device/rescan</span><br><span class="line">#3.查看新的大小是否被识别</span><br><span class="line">fdisk -l</span><br><span class="line">#4.识别后创建新的分区,并且修改文件系统类型  </span><br><span class="line">fdisk /dev/sda</span><br><span class="line">#使用p创建新的分区，起止点默认，不要修改，否则可能把已经存在的数据抹除</span><br><span class="line">#使用t把新创建的分区类型改为Linux LVM ,按下w保存退出</span><br><span class="line">#保存后，运行以下命令生效</span><br><span class="line">partprobe</span><br><span class="line">#5.创建物理卷 </span><br><span class="line">pvcreat /dev/sda3   # /dev/sda3是在上一步新创建的分区</span><br><span class="line">#6.接下来就是操作方案一的3-6步了~</span><br></pre></td></tr></table></figure></p>
<p><a name="89d5f773"></a></p>
<h4 id="方案二演示"><a href="#方案二演示" class="headerlink" title="方案二演示"></a>方案二演示</h4><p><img src="https://cdn.nlark.com/yuque/0/2019/gif/148941/1555135751098-6e1bff6a-feb1-4c9d-b2c3-a1073826ebb1.gif#align=left&amp;display=inline&amp;height=324&amp;name=lvm1.gif&amp;originHeight=546&amp;originWidth=1259&amp;size=1355126&amp;status=done&amp;width=746" alt="lvm1.gif"><br><a name="QkTlH"></a></p>
<h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>在方案二的基础上，还有一个变种，有可能存在前期由于方便，创建了整个磁盘作为pv，这个时候就不能用方案二的方式来通过增加LVM分区的形式来增加PV的大小了，而是有一种更简便的方案，直接resize之前的pv的大小即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#/dev/sdc 在扩容之前已经是一个LVM磁盘，但是不存在分区，在增加磁盘容量后，这里通过以下方法可以直接扩容PV</span></span><br><span class="line"> <span class="comment">#的的大小</span></span><br><span class="line"> <span class="comment">#重新扫描磁盘并resize</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'1'</span> &gt; /sys/class/scsi_disk/0\:0\:0\:0/device/rescan </span><br><span class="line"><span class="built_in">echo</span> <span class="string">'1'</span> &gt; /sys/class/scsi_disk/0\:0\:1\:0/device/rescan</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'1'</span> &gt; /sys/class/scsi_disk/0\:0\:2\:0/device/rescan </span><br><span class="line"><span class="built_in">echo</span> <span class="string">'1'</span> &gt; /sys/class/scsi_disk/0\:0\:3\:0/device/rescan</span><br><span class="line"><span class="comment">#resize PV</span></span><br><span class="line">pvresize  /dev/sdc</span><br><span class="line"><span class="comment">#resize后，查看vg的容量，新增了未分配的空间 </span></span><br><span class="line">vgdisplay</span><br><span class="line"><span class="comment">#直接扩容逻辑卷</span></span><br><span class="line">lvextend -l +100%FREE /dev/centos/root</span><br><span class="line"><span class="comment">#使其生效</span></span><br><span class="line">xfs_growfs  /dev/centos/root</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>MYSQL高可用架构之MHA实践</title>
    <url>/2019/04/10/yuque/MYSQL%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a name="e05dce83"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案<br><a name="cc1caed7"></a></p>
<h2 id="经典架构"><a href="#经典架构" class="headerlink" title="经典架构"></a>经典架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1554915686127-d71fec5a-fc64-4ba2-8e3c-e1b4c1454841.png#align=left&amp;display=inline&amp;height=212&amp;name=image.png&amp;originHeight=179&amp;originWidth=554&amp;size=14746&amp;status=done&amp;width=657" alt="image.png"><br>说明：<br>1.MHA-manager可以安装在除MYSQL-Master以外的任意服务器，唯一的要求是能和所有的DB服务器进行SSH通信<br>2.在所有的MYSQL服务器上安装MHA-node</p>
<p>工作流程  <br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1554915722853-6b1fd0ca-9897-4750-8336-5733fdfefe31.png#align=left&amp;display=inline&amp;height=400&amp;name=image.png&amp;originHeight=400&amp;originWidth=553&amp;size=63651&amp;status=done&amp;width=553" alt="image.png"><br><a name="039d392c"></a></p>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p><a name="be66014c"></a></p>
<h3 id="keepalive配置"><a href="#keepalive配置" class="headerlink" title="keepalive配置"></a>keepalive配置</h3><p>keep主要提供故障切换时候的VIP漂移<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum install keepalived -y</span><br></pre></td></tr></table></figure></p>
<p>配置<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   smtp_server 192.168.200.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_MASTER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_110 &#123;</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 110</span><br><span class="line">    nopreempt</span><br><span class="line">    priority 110</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass keepalived</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.206.144</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">根据 priority 字段自动判别主备，所以这个配置，在三台服务器之间应该不一致</span><br></pre></td></tr></table></figure></p>
<p><a name="ecc9cfd4"></a></p>
<h3 id="数据库主从配置"><a href="#数据库主从配置" class="headerlink" title="数据库主从配置"></a>数据库主从配置</h3><p>配合5.6数据库新特性，配置主从变得异常简单，需要开启GTID，需要启用这三个参数，所有数据库添加该配置，先主库后从库，添加配置后，需要重启MySQL服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/mysql/my.cnf    </span><br><span class="line"><span class="comment">#GTID  </span></span><br><span class="line">gtid_mode = on  </span><br><span class="line">enforce_gtid_consistency = 1  </span><br><span class="line">log_slave_updates   = 1</span><br></pre></td></tr></table></figure>
<p>创建主从复制的用户，并在从库配置认主<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建主从复制用户</span></span><br><span class="line">grant replication slave on *.* to <span class="string">'repl'</span>@<span class="string">'192.168.0.%'</span> identified by <span class="string">'repl'</span>;</span><br><span class="line"><span class="comment">#创建主从复制</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=<span class="string">'192.168.206.129(主库ip)'</span>,MASTER_USER=<span class="string">'repl'</span>, MASTER_PASSWORD=<span class="string">'repl'</span>, MASTER_AUTO_POSITION=1;</span><br></pre></td></tr></table></figure></p>
<p><a name="41c777f5"></a></p>
<h3 id="MHA相关配置"><a href="#MHA相关配置" class="headerlink" title="MHA相关配置"></a>MHA相关配置</h3><p><strong>各主机ssh免密码登录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen  <span class="comment">#每台MySQL服务器执行，生成密钥对  </span></span><br><span class="line">ssh-copy-id  -i root@172.17.99.x  <span class="comment">#每台MySQL服务器执行，分发自己的公钥  </span></span><br><span class="line"><span class="comment">##测试免登陆</span></span><br><span class="line">ssh ⦁	root@172.17.99.x</span><br><span class="line"><span class="comment">##免登陆配置完成</span></span><br></pre></td></tr></table></figure>
<p><strong>MHA 工具部署  </strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##所有节点部署MHA_node  </span></span><br><span class="line"><span class="comment">##centos7需要注释安装脚本中安装lib部分，用 yum install perl-DBD-mysql 安装依赖</span></span><br><span class="line">tar zxvf mha_node.tar.gz <span class="comment">#文件见附件  </span></span><br><span class="line"><span class="built_in">cd</span>  tar zxvf mha_node</span><br><span class="line">bash install.sh  i  </span><br><span class="line"><span class="comment">##管理节点部署MHA_Manager，不要部署在master上  </span></span><br><span class="line"><span class="comment">##centos7需要注释安装脚本中安装lib和Perl库部分,用 yum install perl-DBD-mysql 安装依赖</span></span><br><span class="line">tar zxvf mha_manager.tar.gz  </span><br><span class="line"><span class="built_in">cd</span>  tar zxvf mha_manager</span><br><span class="line"></span><br><span class="line">修改config.ini相关配置 如下</span><br><span class="line"><span class="comment"># SQL服务器列表  </span></span><br><span class="line">iplist=<span class="string">"172.17.99.33 172.17.99.34 172.17.99.42"</span>  </span><br><span class="line"><span class="comment">#绑定的vip，第一次启动需要手动绑定在master  </span></span><br><span class="line">virtual_ip=<span class="string">"172.17.99.43"</span>      <span class="comment">#所有节点机这条内容需一致  </span></span><br><span class="line"><span class="comment"># 绑定vip的网卡  </span></span><br><span class="line">orig_mac_name=<span class="string">"eth0"</span>    <span class="comment">#当前master对应的vip网卡名  </span></span><br><span class="line">new_mac_name=<span class="string">"eth0"</span>     <span class="comment">#高可用漂移目标主机网卡  </span></span><br><span class="line"><span class="comment"># mysql管理的账号，需要的权限近似root  </span></span><br><span class="line">db_user=<span class="string">"root"</span>  </span><br><span class="line">db_password=<span class="string">"root"</span>  </span><br><span class="line"><span class="comment"># mysql数据AB复制账号  </span></span><br><span class="line">db_repl_user=<span class="string">"repl"</span>  </span><br><span class="line">db_repl_pwd=<span class="string">"repl"</span>  </span><br><span class="line"><span class="comment"># 系统账号及密码  </span></span><br><span class="line">ssh_user=<span class="string">"root"</span>  </span><br><span class="line"><span class="comment"># 关闭mysql事件  </span></span><br><span class="line">db_event=0  </span><br><span class="line">bash install.sh  i </span><br><span class="line">yum install perl-DBD-mysql</span><br><span class="line">MHA部署完成</span><br></pre></td></tr></table></figure></p>
<p><strong>服务运行检查</strong><br>在启动服务前，先检查配置，检查ssh免登陆配置<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">masterha_check_ssh --conf=/usr/<span class="built_in">local</span>/mha/etc/app.cnf</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1554915806997-5df6220d-fbab-42fc-818c-3dd62e0b0e80.png#align=left&amp;display=inline&amp;height=419&amp;name=image.png&amp;originHeight=419&amp;originWidth=780&amp;size=57363&amp;status=done&amp;width=780" alt="image.png"><br>检查主从复制状态，不报错即通过<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">masterha_check_repl  --conf=/usr/<span class="built_in">local</span>/mha/etc/app.cnf</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1554916084449-5bd7565f-c81a-476d-bab9-3b9a3dae6a11.png#align=left&amp;display=inline&amp;height=419&amp;name=image.png&amp;originHeight=419&amp;originWidth=780&amp;size=54731&amp;status=done&amp;width=780" alt="image.png"><br>服务运行  <br>以上两项通过后，确认在当前的master上启动VIP，然后在MHA_ manager启动服务<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">masterha_manager --conf=/usr/<span class="built_in">local</span>/mha/etc/app.cnf</span><br></pre></td></tr></table></figure></p>
<p><strong>安装信息  </strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装目录：  </span></span><br><span class="line">/usr/bin  </span><br><span class="line"><span class="comment">#配置文件：  </span></span><br><span class="line">/etc/masterha_default.cnf, /usr/<span class="built_in">local</span>/mha/etc/app.cnf  </span><br><span class="line"><span class="comment">#日志文件</span></span><br><span class="line">/data/logs/mha/mha.log  </span><br><span class="line"><span class="comment">##基本命令  </span></span><br><span class="line"><span class="comment">#启动：  </span></span><br><span class="line">masterha_manager --conf=/usr/<span class="built_in">local</span>/mha/etc/app.cnf  </span><br><span class="line"><span class="comment">#关闭：  </span></span><br><span class="line">masterha_stop --conf=/usr/<span class="built_in">local</span>/mha/etc/pp.cnf  </span><br><span class="line"><span class="comment">#查看状态：  </span></span><br><span class="line">masterha_check_status --conf=/usr/<span class="built_in">local</span>/mha/etc/app.cnf</span><br></pre></td></tr></table></figure></p>
<p><a name="8224197f"></a></p>
<h2 id="验证方案"><a href="#验证方案" class="headerlink" title="验证方案"></a>验证方案</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#模拟主库发生故障  </span></span><br><span class="line"><span class="comment">#模拟前可以查看日志，查看故障切换过程  </span></span><br><span class="line">tailf  /data/logs/mha/mha.log </span><br><span class="line"><span class="comment">#配合5.6数据库新特性，需要开启GTID，需要启用这三个参数，所有数据库添加该配置，先主库后从库，添加配置后，需要重启MySQL服务</span></span><br><span class="line">vim /usr/<span class="built_in">local</span>/mysql/my.cnf    </span><br><span class="line"><span class="comment">#GTID  </span></span><br><span class="line">gtid_mode = on  </span><br><span class="line">enforce_gtid_consistency = 1  </span><br><span class="line">log_slave_updates   = 1   </span><br><span class="line"><span class="comment">#重启数据库  </span></span><br><span class="line">/etc/init.d/mysqld  restart  </span><br><span class="line"><span class="comment">#停止主数据库,命令仅供参考</span></span><br><span class="line">/etc/init.d/mysqld  stop  </span><br><span class="line"><span class="comment">#根据日志信息，查看新的主库是否成功的启用了VIP,并确认故障的服务器已经关闭了VIP  </span></span><br><span class="line"><span class="comment">#成功切换后，业务上不会有任何影响，然后恢复故障的数据库  </span></span><br><span class="line"><span class="comment">#启动原来的主库，并同步从库同步位置  </span></span><br><span class="line">/etc/init.d/mysqld  start    </span><br><span class="line">CHANGE MASTER TO MASTER_HOST=<span class="string">'172.17.99.x(新主库IP)'</span>,MASTER_USER=<span class="string">'repl'</span>, MASTER_PASSWORD=<span class="string">'repl'</span>, MASTER_AUTO_POSITION=1;  </span><br><span class="line"><span class="comment">## 要把之前的主库再次作为主库的话，可以再次模拟新的主库出现问题，将主库切换回旧主库  </span></span><br><span class="line"><span class="comment">##由于mha的机制，8个小时不会多次failover，所以先删除failover记录  </span></span><br><span class="line"> rm -rf /data/mha/starcor_app/app.failover.complete  </span><br><span class="line"><span class="comment">#停止主数据库，在新的主库上操作  </span></span><br><span class="line">/etc/init.d/mysqld  stop  </span><br><span class="line"><span class="comment">#根据日志信息，查看新的主库是否成功的启用了VIP,并确认故障的服务器已经关闭了VIP  </span></span><br><span class="line"><span class="comment">#验证成功</span></span><br></pre></td></tr></table></figure>
<p>  <a href="https://www.yuque.com/attachments/yuque/0/2019/gz/148941/1557977914459-46d3764d-1c16-4486-9dc7-35aaac51ed49.gz?_lake_card=%7B%22uid%22%3A%221557977898578-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2019%2Fgz%2F148941%2F1557977914459-46d3764d-1c16-4486-9dc7-35aaac51ed49.gz%22%2C%22name%22%3A%22mha_manager.tar.gz%22%2C%22size%22%3A15037605%2C%22type%22%3A%22application%2Fgzip%22%2C%22ext%22%3A%22gzip%22%2C%22progress%22%3A%7B%22percent%22%3A0%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22card%22%3A%22file%22%7D" target="_blank" rel="noopener">mha_manager.tar.gz</a><br><a href="https://www.yuque.com/attachments/yuque/0/2019/gz/148941/1554916886562-338d2559-b971-40fa-a87f-455c20ef02aa.gz?_lake_card=%7B%22uid%22%3A%22rc-upload-1554916526465-11%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2019%2Fgz%2F148941%2F1554916886562-338d2559-b971-40fa-a87f-455c20ef02aa.gz%22%2C%22name%22%3A%22mha_node.tar.gz%22%2C%22size%22%3A870934%2C%22type%22%3A%22application%2Fgzip%22%2C%22ext%22%3A%22gzip%22%2C%22progress%22%3A%7B%22percent%22%3A0%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22card%22%3A%22file%22%7D" target="_blank" rel="noopener">mha_node.tar.gz</a></p>
]]></content>
  </entry>
  <entry>
    <title>win10永久数字激活汉化版</title>
    <url>/2019/04/09/win10%E6%B0%B8%E4%B9%85%E6%95%B0%E5%AD%97%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数字许可证是Windows 10新采用的更简单，更有效的激活/授权方式，<br>仅依赖于计算机硬件的配置信息。首次激活系统后，只要您不更改CPU<br>和连接到主板的其他设备，您就可以随时连接到Microsoft服务器，以反<br>复，自动和永久激活您的Windows 10，而无需每次安装系统时都必须反<br>复输入产品密钥。<br>对于Windows 10，无论它是如何激活的（从Windows7/8.1升级，是购买的零售版本，或与BIOS绑定，即MSDM许可证），<br>激活将转换为相应硬件的唯一数字许可证ID（HWID）。此许可证将被发送并存储在Microsoft服务器上，<br>然后每次全新安装Windows并成功连接到MS服务器时，它将自动激活此计算机。在硬件更改之前，此许可证将<br>保持有效。当然，将其绑定到您的Microsoft帐户可以实现将许可证转移到具有不同硬件配置的另一台计算机的目标<br>这里是关于数字激活的<a href="https://support.microsoft.com/zh-cn/help/12440/windows-10-activation" target="_blank" rel="noopener">官方介绍</a>  </p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://u19829043.ctfile.net/fs/19829043-362721973" target="_blank" rel="noopener">点击这里下载</a>，解压密码： dingtalk</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般情况下，打开软件湖，选择右上角的 HWID ,然后点击左下角开始，即可永久激活<br>备注：所有的激活类软件都会报毒，如果失败，请关闭安全类软件。 推荐使用<a href="https://www.virustotal.com/#/home/upload" target="_blank" rel="noopener">virustotal</a>进行权威完整的扫描。<br><img src="https://user-images.githubusercontent.com/16778873/55774029-04ad4700-5ac6-11e9-9f70-e09e29293b1b.gif" alt><br>怎么查看是否永久激活 ？<br><a href="https://jingyan.baidu.com/article/7f766daf8063c64101e1d0eb.html" target="_blank" rel="noopener">百度一下咯</a><br>或者<code>win+R</code> 运行 <code>Slmgr.vbs  -xpr</code> </p>
<h2 id="支持的win10版本"><a href="#支持的win10版本" class="headerlink" title="支持的win10版本"></a>支持的win10版本</h2><ul>
<li>Core (Home) (N) &lt;HWID/ KMS38™&gt;  </li>
<li>CoreSingleLanguage (N) &lt;HWID/ KMS38™&gt;  </li>
<li>Professional (N) &lt;HWID/ KMS38™&gt;  </li>
<li>ProfessionalEducation (N) &lt;HWID/ KMS38™&gt;  </li>
<li>ProfessionalWorkstation (N)&lt;HWID/ KMS38™&gt;  </li>
<li>Education (N)&lt;HWID/ KMS38™&gt;  </li>
<li>Enterprise (N)&lt;HWID/ KMS38™&gt;  </li>
<li>EnterpriseS  (N) 2015 <hwid>  </hwid></li>
<li>EnterpriseS (N) 2016 &lt;HWID/ KMS38™&gt;  </li>
<li>EnterpriseS  (N)  &lt;KMS38™&gt;  </li>
<li>ServerStandard(Core) (N) &lt;KMS38™&gt;  </li>
<li>ServerDatacenterCore) (N) &lt;KMS38™&gt;  </li>
<li>ServerSolution(Core) (N) &lt;KMS38™&gt;  </li>
</ul>
<h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p>  <img src="https://user-images.githubusercontent.com/16778873/56295947-2ced1380-6160-11e9-956d-f659c257e299.png" alt="数字激活">  </p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本站所提供的所有软件均来自于互联网，个人存放在此作为备用，以备将来不时之需，同时作为大家的分享和学习成果，仅供个人研究和学习使用，请勿用于商业用途，下载后请于24小时内删除，请支持正版！</p>
]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>win10</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Microsoft Toolkit 安全激活工具</title>
    <url>/2019/04/08/Microsoft%20Toolkit%20%E6%BF%80%E6%B4%BB%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="关于Microsoft-Toolkit"><a href="#关于Microsoft-Toolkit" class="headerlink" title="关于Microsoft Toolkit"></a>关于Microsoft Toolkit</h3><p>Microsoft Toolkit 2.6.7是用于激活Microsoft Office和Microsoft Windows的最受信任的激活器</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>第1步</strong>：禁用Windows保护防病毒。（防病毒阻止KMS Microsoft工具包系统）<br><strong>第2步</strong>：现在，通过上面的按钮下载Microsoft Toolkit。<br><strong>步骤3</strong>：双击.exe文件并选择要激活的产品。<br><strong>第4步</strong>：在PC系统上安装。<br><strong>步骤5</strong>：重新启动PC，最后激活Windows或Office<br><img src="https://user-images.githubusercontent.com/16778873/55699147-03174c80-59fc-11e9-9f23-49959d3c7dfe.gif" alt></p>
<h3 id="支持的系统"><a href="#支持的系统" class="headerlink" title="支持的系统"></a>支持的系统</h3><p>待补充~~</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="http://u19829043.ctfile.net/fs/19829043-361400362" target="_blank" rel="noopener">点击这里下载</a> 当前版本：2.6.7</p>
]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>soft</tag>
      </tags>
  </entry>
  <entry>
    <title>Valine出现Code 403 访问被api域名白名单拒绝，请检查你的安全域名设置</title>
    <url>/2019/04/08/yuque/Valine%E5%87%BA%E7%8E%B0Code%20403%20%E8%AE%BF%E9%97%AE%E8%A2%ABapi%E5%9F%9F%E5%90%8D%E7%99%BD%E5%90%8D%E5%8D%95%E6%8B%92%E7%BB%9D%EF%BC%8C%E8%AF%B7%E6%A3%80%E6%9F%A5%E4%BD%A0%E7%9A%84%E5%AE%89%E5%85%A8%E5%9F%9F%E5%90%8D%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p><a name="8e1b944f"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前期把hexo的静态页面部署在GH,Valine所有功能正常，但是在部署到<a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlif</a>，在自定义的域名开启https之后，Valine出现报错 <code>Code 403: 访问被api域名白名单拒绝，请检查你的安全域名设置</code><br><a name="4b86211f"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在leancloud的<code>应用&gt;设置&gt;安全中心&gt;Web安全域名</code>中只添加了新的自定义的域名即可解决该问题，</p>
]]></content>
  </entry>
  <entry>
    <title>centos7安装shadowsocks客户端全局代理</title>
    <url>/2019/04/07/yuque/centos7%E5%AE%89%E8%A3%85shadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p><a name="5f9de052"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近使用一个开源的项目，在安装依赖的时候，使用的是composer，使用国内的源的情况下，部分依赖，国内的镜像站没有，于是直接使用官方的源。开始之前，取消所有的设置的非官方源  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">composer config -g --<span class="built_in">unset</span> repos.packagist</span><br></pre></td></tr></table></figure>
<p><a name="dfa274a2"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a name="1b9c7b3a"></a></p>
<h3 id="高级加密算法支持"><a href="#高级加密算法支持" class="headerlink" title="高级加密算法支持"></a>高级加密算法支持</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载 libsodium 最新版本</span></span><br><span class="line">wget https://github.com/jedisct1/libsodium/releases/download/1.0.17/libsodium-1.0.17.tar.gz</span><br><span class="line">tar xzvf libsodium-1.0.17.tar.gz</span><br><span class="line"><span class="built_in">cd</span>  libsodium</span><br><span class="line"><span class="comment">#编译并且安装</span></span><br><span class="line">make -j8 &amp;&amp; make install</span><br><span class="line"><span class="comment">#添加运行库位置并加载运行库</span></span><br><span class="line"><span class="built_in">echo</span> /usr/<span class="built_in">local</span>/lib &gt; /etc/ld.so.conf.d/usr_local_lib.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
<p><a name="d37840b1"></a></p>
<h3 id="ss客户端"><a href="#ss客户端" class="headerlink" title="ss客户端"></a>ss客户端</h3><p>安装最新的ss客户端  <br>使用以下命令安装最新的客户端（不要仅仅简单的使用 <code>pip install  shadowsocks</code> 来安装，因为不支持一些高级加密算法）  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U</span><br></pre></td></tr></table></figure>
<p><a name="bc62b762"></a></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim  /etc/shadowsocks.json <span class="comment">##以下配置根据自己的服务器信息填写</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"server"</span>:<span class="string">"x.x.x.x"</span>,             <span class="comment">#你的 ss 服务器 ip</span></span><br><span class="line">  <span class="string">"server_port"</span>:0,                <span class="comment">#你的 ss 服务器端口</span></span><br><span class="line">  <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,   <span class="comment">#本地ip</span></span><br><span class="line">  <span class="string">"local_port"</span>:1080,                 <span class="comment">#本地端口</span></span><br><span class="line">  <span class="string">"password"</span>:<span class="string">"password"</span>,          <span class="comment">#连接 ss 密码</span></span><br><span class="line">  <span class="string">"timeout"</span>:300,                  <span class="comment">#等待超时</span></span><br><span class="line">  <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,         <span class="comment">#加密方式</span></span><br><span class="line">  <span class="string">"workers"</span>: 1                    <span class="comment">#工作线程数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="8e54ddfe"></a></p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">" nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;"</span> /etc/rc.local   <span class="comment">#设置自启动</span></span><br></pre></td></tr></table></figure>
<p><a name="db06c78d"></a></p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>运行 <code>curl --socks5 127.0.0.1:1080  http://httpbin.org/ip</code>，如果返回你的 ss 服务器 ip 则测试成功：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;origin&quot;: &quot;x.x.x.x&quot;       #你的 ss 服务器 ip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a name="Privoxy"></a></p>
<h3 id="Privoxy"><a href="#Privoxy" class="headerlink" title="Privoxy"></a>Privoxy</h3><p>Shadowsocks 是一个 socket5 服务，我们需要使用 Privoxy 把流量转到 http/https 上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以直接安装</span></span><br><span class="line">yum install Privoxy -y </span><br><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">vim /etc/privoxy/config</span><br><span class="line"><span class="comment">#添加以下行，不要漏了  .</span></span><br><span class="line">forward-socks5t / 127.0.0.1:1080 .</span><br><span class="line">配置 /etc/profile</span><br><span class="line">vim  /etc/profile</span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118       <span class="comment">#这里的端口和上面 privoxy 中的保持一致</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:8118</span><br><span class="line"><span class="comment"># 重新加载全局环境</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment">#测试生效</span></span><br><span class="line">curl www.google.com  </span><br><span class="line">返回一大堆 HTML 则说明 shadowsocks 正常工作了</span><br></pre></td></tr></table></figure>
<p><a name="7a0a21d5"></a></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果不需要用代理了，记得把 <code>/etc/profile</code> 里的配置注释掉，不然会一直走代理流量</p>
]]></content>
  </entry>
  <entry>
    <title>Beyond Compare直装破解版</title>
    <url>/2019/04/01/Beyond%20Compare%E7%9B%B4%E8%A3%85%E7%A0%B4%E8%A7%A3%E7%89%88/</url>
    <content><![CDATA[<h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p>Beyond Compare是一款Scooter Software研发的文件对比工具。你可以选择针对多字节的文本、文件夹、源代码，<br>甚至是支持比对adobe文件、pdf文件或是整个驱动器，检查其文件大小、名称、日期等信息<br><strong>智能的比较工具</strong><br>只需用简单而强大的操作命令，即可开启最优质的对比体验，找出你感兴趣的差异，合并变化，然后同步文件，并生成报告。<br><strong>多种文件格式对比</strong><br>Beyond Compare包含多种数据类型的内置比较浏览器，除了文本之外，还可以进行表格、图片、二进制文件、注册表的比较。<br><strong>全面文件类型支持</strong><br><a href="http://www.beyondcompare.cc/jiqiao/wenjianjia-bijiao.html" target="_blank" rel="noopener">文件夹比较</a><br><a href="http://www.beyondcompare.cc/jiqiao/wenjianjia-hebing.html" target="_blank" rel="noopener">文件夹合并</a><br><a href="http://www.beyondcompare.cc/jiqiao/tongbu-xiangjie.html" target="_blank" rel="noopener">文件夹同步</a><br><a href="http://www.beyondcompare.cc/jiqiao/wenben-bijiao.html" target="_blank" rel="noopener">文本比较</a><br><a href="http://www.beyondcompare.cc/jiqiao/wenjian-hebing.html" target="_blank" rel="noopener">文本合并</a><br><a href="http://www.beyondcompare.cc/jiqiao/biaoge-bijiao.html" target="_blank" rel="noopener">表格比较</a><br><a href="http://www.beyondcompare.cc/jiqiao/shiliu-jinzhi.html" target="_blank" rel="noopener">16进制比较</a><br><a href="http://www.beyondcompare.cc/jiqiao/mp3-wenjian.html" target="_blank" rel="noopener">MP3比较</a><br><a href="http://www.beyondcompare.cc/jiqiao/tupian-bijiao.html" target="_blank" rel="noopener">图片比较</a><br><a href="http://www.beyondcompare.cc/jiqiao/zhucebiao-bijiao.html" target="_blank" rel="noopener">注册表比较</a><br><a href="http://www.beyondcompare.cc/jiqiao/" target="_blank" rel="noopener">其他教程</a>  </p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="http://u19829043.ctfile.net/fs/19829043-357924027" target="_blank" rel="noopener">点这里下载</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>解压，解压密码为： <code>imdingtalk</code>  解压后直接安装即为破解版，可以直接使用啦你值得拥有</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本站所提供的所有软件均来自于互联网，个人存放在此作为备用，以备将来不时之需，同时作为大家的分享和学习成果，仅供个人研究和学习使用，请勿用于商业用途，下载后请于24小时内删除，请支持正版!!!</p>
]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>soft</tag>
      </tags>
  </entry>
  <entry>
    <title>你说是啥就是啥</title>
    <url>/2019/03/31/%E4%BD%A0%E8%AF%B4%E6%98%AF%E5%95%A5%E5%B0%B1%E6%98%AF%E5%95%A5/</url>
    <content><![CDATA[<p>拍电影看照片，就是很快要牺牲了~</p>
<p>那有什么岁月静好，只是有人替我们负重前行而已  </p>
<p>也许干掉自己的不是同类，而是跨界。  </p>
<p>摆脱坏习惯，习惯的环路是，暗示-&gt;惯常行为-&gt;奖赏。 简单的破坏这样一个环路中的任何一个环节，即可改变习惯。  </p>
<p>例如，你每次想去冰箱拿一点吃的，可乐，或者其他什么垃圾食品，每当你想吃点什么的时候，你就会得到暗示，从而产生惯常行为-&gt;去冰箱找喜欢吃的东西，从而满足大脑对行为的奖赏。满足了口欲。能不能，我们就把白开水一直放在身边呢，我们依然还是会收到暗示，我们饿了，或者渴了，我们需要去找点吃的，喝的（暗示），如果这个时候，我们身边刚好就有健康的食品，比如水果，白开水放在身边，我们极有可能，就近的选择直接喝近在咫尺的水喝健康的水果（把惯常行为变得和之前不同），这样我们也可以得到奖赏。  完成了一个习惯回路，暗示-&gt;惯常行为-&gt;奖赏；可见仅仅一个小小的改变，就可以改变一直以来的坏习惯。<br>那么如何去养成一个好的习惯呢，习惯的力量说，人每天有60%的行为都是受到习惯的支配，这并不是坏事，习惯是我们进化出的面对复杂的事物的一种高级的事物，因为习惯，往往带来更高效的行为，比如我们的走路，如果我们迈出的每一步，都需要大脑的参与，那大脑可能就无暇处理更多的事情了吧（走路都要大脑参与，那全身的其他更基础的事情，如呼吸，肯定也是大脑参与了），所有，这种习惯性的事物，确实能给我们带来一些好处； 那么，能养成良好的习惯就变得至关重要了。  那么如何能养成好的习惯呢，前面说了，一个不好的习惯，只要改变，习惯环路中的一点，就可以形成新的习惯，我们或许可以使用这样的规律，来改变不好的习惯，养成好的习惯。  善于利用习惯环路，暗示-&gt;惯常行为-&gt;奖赏，使用积极的暗示，来使自己产生好的惯常希望，可能一开始是很难得。 以为，大脑，总想偷懒嘛，新的习惯，意味着更多的大脑参与时间，是很费神的，但是好的习惯，一旦养成，大脑就基本不再参与习惯的事儿了。比如，呼吸，掌握身体平衡这样简单的事物，如今，已经完全不需要大脑的参与了。 有更基础的部分来掌握这些行为，那些都是身体所产生的习惯，极少出错。</p>
<p>虽然我还没遇见你,我一定会爱上你~</p>
<p>曼德拉效应，不要相信自己的记忆~ 用文字记录下来吧~  </p>
<p>习惯回路，有<strong>暗示</strong>，从而产生<strong>惯常行为</strong>，进而获得<strong>奖赏</strong>，这是每个人的必须，在一定的暗示下，期待获得一个期待的结果，但是并不是所有的惯常行为都是好的；比如，想要在逃避现实的时候多喝酒。 而好的习惯，至少可以影响我们每天70%左右的行为；不知道什么时候起，我害怕失败，害怕行动，只是碌碌无为也可以短暂满足，安逸的享受现在。如果可以，我是不是可以在每次遭遇到这种情况的时候，更多的去做一些什么呢，而不是喝酒，娱乐呢。<br>习惯的改变，实际就是惯常行为的改变，我们无法规避<strong>暗示</strong>，我们也无法逃避<strong>奖赏</strong>，因为，如果没有意义，我们为什么要做呢；说到这个，我爱的你。你觉得没有意义，我觉得有意义；所以，我们改变习惯的关键，就是修正我们的惯常行为。后面的话，我就注意下我日常中的习惯了，看看有没有什么可以改进的地方，废话，当然需要改啦。<br>遇到事情的时候，暗示：能做尽快做吧，不行尽快放弃了-&gt;惯常行为：不回应不积极主动-&gt;奖赏：安逸的享受，偷懒爽歪歪；改进惯常行为：积极主动处理，不会的话，刚好是一个学习的机会-&gt;学会后可以感觉爽歪歪呢，事情做完了不也是爽歪歪么~   </p>
<p>神秘代码：3019803  4741929   4771253</p>
<p>“要说分手你就好好说啊，不要不接电话，别人会担心你的安全知道吗，你开车又爱走神，我好害怕你出事，分手就分啊你不要吓我”</p>
<p><strong>少壮不努力，一生在内地</strong>  </p>
]]></content>
      <tags>
        <tag>myself</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo给文章加密的实现</title>
    <url>/2019/03/28/hexo%E7%BB%99%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read. password is 123</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="9747b986906c1ae7d3d79e646fe16248d19e99602aecf27cc989c66eddfbb71f">2d98291ee7a6f96cbdec765c67f15b6fc28cf8e0745e80825544a96a24e62524d506c4adb72cae256dca069f131f083caeda50cec1da4cb529033ad809cdb519206812a669d10df26f75413f17c96408e7de34471675f04df158b29513dae9bc4bb402af6cc4f121a31327ef96d0ef237df07071d9583c578fea90b55d84fe4ca137fd1ac465250e483b762ce31c54aaf38f454987e738d676e644d307e8ba588a78fb4dd80af650989b46bd2e4c7b56db348687c44437da4a044e3c91ca31cc13b716d9c4c439205b0e01809d1a4aea2bc73d499ff73f741ded53b57a4043a2803af3af2231794e37565140ec29bcee260ba8bfb98e2cbabaf2fe9c09b9de1e8a77861943553126bf1e2fcab9b51d1432d1e266a7b65a3f792d7ce87cc1b6221c3f353f405b80d3fdca4bb2ae54e353afbd8c788fcd950cfce531734d7543ab815cdbe0f46bda2a7ebfeba8ce5044e605a7f6779f19de3d9fcb5965245b942d928a168c6510796abc120eea749e7a6bdd8a26183870dabb5a9e279ba6f647b53349b5d51c8df84160fe09d7260f3d9e671d85a3df3f13ab511e424209ca9a51fd798a0ab0dca13c3f48f62a5020c88434cb752f8ed4a8dfaebc1daba9e24938d2e3b5708b7f7b390885c279cd9302947589edd26625b5563df9a8e4c627af2c88c381f4149f83b3578728ad0660507815dd96796e94ba7229a8776d7d2675ee3213dd9b41103d7ee6274837bcd451a2a468364fd6f317d2ddbe6823d0f305a2ee7b6c69d06173dfdfe9c672b08628b69101d81a06283b04d92f7d2a389ef7a0cd6cff26ac4d23c25da3f368a232bae517acd9f660280654ed594752866ec64b929db1c8856e66d63f2fc372c0d194f1240b340eb985754a8a7c7c93fcae5bf7aea0d3749bfe53f524b825c646e5805aadfa7c20ad44e41fb5face31719b61aea0fe331a50292685e6266e570472ea277f3da5941a482ea4fbc57640d56c57e865241f4a9e6318846ce25ee1c44f3cf542d624ce6a36f599512e96292d97066c1597979173f898ea11a755d92142b5621c5d1d868c574901ea1ab43c74f002c7e2c914bf08e99f712d8252fc3800f2fb6610d12c89a9303dc2630454808e5238766b8c4f529779d54d87c899a6c2384a53c1969860f64466e7feb9265439e7477b5203723eaeddf3039b7d9c4ce9dfb91fb89e1914c36c7d4f752d8e9f61da0c7e71e310bbb5663ee8c58130a2b7f39996476752f4ec04b55245c406bdf6240db24b25ad6a3dc89a8ebef311122113211318a68da3ab9a9f186ffb66f09017a2ca70382c8bfe6bed4ca8ea1487f4d3e3ac3f2b6d6089adce243f7427c8806e8f01404a37371098260d5844827a4416c2e0ea0dc92af8dd5248ba8f8bdcaaffa235c1cb7496aa4ae5c35f0b60b63500958cdc8a2631f6f8eb2939647a8f97ca8e561c9727e5ea033ead47897a2f23b54a493ad85887b7f7b8001a2f7e93fa4c2f5ca4e7040e53b037939e56874c2b0b2ccda31abc061db79ffa3e50ce25e0c1a3362c387d7f391a0dc1eca8f2dc0dbbcab3c15e253bdfb032ebab758cedd857f476f1154bb3f3873f081e9c101ab51ba8f1bef44c2cc8790899ff2cff6a42c879efed7cbacbdd5a044ed1466659f97ebdde9732e0d73a560216dc8e0f980a756227b4466af7c0e8f7cbb44572d42b5932a3fbcdbf4152703e0440c1fcb773394bb70f6f2bb52f64e39b975705f1b6923eef6905c0896428d8d46ea2c5e2393959</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>v2ray在heroku中搭建翻墙</title>
    <url>/2019/03/28/v2ray%E5%9C%A8heroku%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%BF%BB%E5%A2%99/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>heroku账号，<a href="https://signup.heroku.com/login" target="_blank" rel="noopener">这里注册</a>，需要fq访问</li>
<li>Travis-CI 账号，使用github账号登录，<a href="https://travis-ci.org/" target="_blank" rel="noopener">官网</a>  </li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>参考： <a href="https://github.com/onplus/v2hero/wiki/Deploy-V2ray-To-Heroku" target="_blank" rel="noopener">Deploy-V2ray-To-Heroku</a><br>安装可以直接使用这个教程，但是他的所涉及的仓库较老（v2ray在新版本更新了目录结构，导致他的老的dockerfile没法直接用），我fork之后，根据新的目录结构更了部分不适用的地方，可以fork我的项目直接在教程的第二步，fork项目那一步，替换为fork<a href="https://github.com/imdingtalk/v2hero" target="_blank" rel="noopener">我的项目</a>，以便直接使用</li>
<li>使用以上教程在，Travis-CI成功build后，v2ray的镜像会上传到heroku,但是不会发布应用，需要在自己的电脑使用heroku-cli，手动发布下<br><code>heroku container:release web -a ddfav2</code><br>-a 参数后跟要发布镜像到哪个应用。</li>
</ol>
]]></content>
      <categories>
        <category>Foreign</category>
      </categories>
      <tags>
        <tag>heroku</tag>
        <tag>fq</tag>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo + Next 优化记录</title>
    <url>/2019/03/28/hexo%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">站点访问量统计</a>  </p>
<h3 id="hexo-插入视频和音乐播放器"><a href="#hexo-插入视频和音乐播放器" class="headerlink" title="hexo 插入视频和音乐播放器"></a>hexo 插入视频和音乐播放器</h3><p>markdown支持原生的HTML代码，直接将音乐播放器的外链播放器代码写在自己的md文档中就行。  </p>
<ol>
<li>获取外链<br>网易云为例，打开网页版客户端：<a href="https://music.163.com/" target="_blank" rel="noopener">https://music.163.com/</a> 使用自己的账号登录，到歌曲详情页,点击生成外链播放器，将自动生成的代码写入到自己的markdown文本中即可</li>
<li>版权问题的音乐<br>谷歌浏览器，F12,然后选择元素追踪，点击<code>生成外链播放器</code>，追踪代码，找到类似 <code>/outchain/0/2691310987/</code> 这样一段，然后拼接地址<br><code>https://music.163.com/#/outchain/0/2691310987/</code>  </li>
<li><p>自己的歌单，没有出现<code>生成外链播放器</code> 按钮 ,需要自己手动拼接地址，在我的音乐中，链接地址类似<code>https://music.163.com/#/my/m/music/playlist?id=97473950</code>,复制这里的<code>id=97473950</code>,做如下拼接<br><code>https://music.163.com/#/playlist?id=97473950</code><br>然后就可以进行第1,2步的操作了</p>
<h3 id="给hexo添加菜单留言板"><a href="#给hexo添加菜单留言板" class="headerlink" title="给hexo添加菜单留言板"></a>给hexo添加菜单留言板</h3><p>留言的系统用的是Valine，这个后面介绍，在Valine已经安装好的前提下（每个文章后面都有留言板的时候），新加一个页面主菜单，作为站点的留言板<br>在source目录下新建一个目录，编辑index.md  添加必要信息  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="built_in">source</span> </span><br><span class="line">mkdir guestbook</span><br><span class="line"><span class="built_in">cd</span> guestbook</span><br><span class="line">vim index.md </span><br><span class="line">---</span><br><span class="line">title: 留言板</span><br><span class="line">date: 2019-03-28 10:57:48</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"guestbook"</span></span><br><span class="line">comments: <span class="literal">true</span></span><br><span class="line">---</span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">在主题配置文件，新增菜单选项,||之前的值是目标链接，之后的是分类页面的图标，图标名称来自于[FontAwesome icon](https://fontawesome.com/icons?from=io)。若没有配置图标，默认会使用问号图标; 然后添加对应的语言翻译  </span><br><span class="line"></span><br><span class="line">  ```yaml</span><br><span class="line">vim theme/next/_config.yml <span class="comment"># menu下新加以下菜单</span></span><br><span class="line">menu:</span><br><span class="line">  guestbook: /guestbook || grin-squint-tears</span><br><span class="line"><span class="comment"># 添加语言翻译  </span></span><br><span class="line">vim themes/next/languages/zh-CN.yml</span><br><span class="line">menu:</span><br><span class="line">  guestbook: 留言板</span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line"><span class="comment">### 显示当前浏览进度</span></span><br><span class="line">打开 themes/next/_config.yml ,搜索关键字 `scrollpercent` ,把 `<span class="literal">false</span>` 改为 `<span class="literal">true</span>` ，如下：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># Scroll percent label in b2t button</span></span><br><span class="line">  scrollpercent: <span class="literal">true</span></span><br><span class="line"><span class="comment">#以上修改好后，已经可以在页面右下角显示当前浏览进度，如果需要添加回到顶部到侧边栏，打开以下配置</span></span><br><span class="line"><span class="comment"># Back to top in sidebar</span></span><br><span class="line"> b2t: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="添加打字特效"><a href="#添加打字特效" class="headerlink" title="添加打字特效"></a>添加打字特效</h3><p>效果如下<br><img src="https://user-images.githubusercontent.com/16778873/55814299-cc872200-5b20-11e9-8077-7d3c56576c69.gif" alt="1234">  </p>
<p>这里<a href="https://script-1256884783.file.myqcloud.com/activate-power-mode.min.js" target="_blank" rel="noopener">下载</a> js文件，放在themes/next/source/js/目录下<br>在主题自定义布局文件中添加以下代码,<code>cat themes/next/layout/_custom/custom.swig</code>,文件不存在则新建  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;# 打字特效 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.typing_effect %&#125;</span><br><span class="line">  &lt;script src=<span class="string">"/js/activate-power-mode.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    POWERMODE.colorful = &#123;&#123; theme.typing_effect.colorful &#125;&#125;;</span><br><span class="line">    POWERMODE.shake = &#123;&#123; theme.typing_effect.shake &#125;&#125;;</span><br><span class="line">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'input'</span>, POWERMODE);</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp">```  </span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">布局页面中 body 末尾引入,添加 ```&#123;% include '_custom/</span>custom.swig<span class="string">' %&#125;```  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ```html</span></span><br><span class="line"><span class="string">      ...</span></span><br><span class="line"><span class="string">      &#123;% include '</span>_third-party/exturl.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">      &#123;% include '</span>_third-party/bookmark.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">      &#123;% include '</span>_third-party/copy-code.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">      &#123;% include '</span>_custom/custom.swig<span class="string">' %&#125;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">  ```  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">最后在主题配置中添加该项  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ```yaml</span></span><br><span class="line"><span class="string">  # typing effect</span></span><br><span class="line"><span class="string">  typing_effect:</span></span><br><span class="line"><span class="string">    colorful: true  # 礼花特效</span></span><br><span class="line"><span class="string">    shake: false  # 震动特效</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>CircleCI+GitHub+hexo 持续集成</title>
    <url>/2019/03/28/yuque/CircleCI+GitHub+hexo%20%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<p><a name="8e1b944f"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前期使用Travis做持续集成，Travis针对开源的项目是没有使用限制的，但是你休想使用一个私有项目区构建你的应用(更新：可以build私有项目，不过有个总限制，用完了，就真的没法了)，搜寻之下，暂时准备用CircleCI替代，补充Travis在私有项目中的个人用途。<br><a href="https://circleci.com/pricing/" target="_blank" rel="noopener">价格参考</a>  – 单容器单job每月1000分钟build时间，不区分私有还是开源项目。<br>一个hexo的build，每次大概只耗时1分钟。单次build时长限制60min(Travis是50min)<br><a name="c182e73c"></a></p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p><a href="https://circleci.com/vcs-authorize/" target="_blank" rel="noopener">这里</a>，直接使用github账户登录。 然后授权要进行ci的repo. <br>在授权项目根目录新建CircleCI的文件夹  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意不要少了 .</span></span><br><span class="line">mkdir .circleci</span><br><span class="line">vim  .circleci/config.yml</span><br></pre></td></tr></table></figure>
<p>示例配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="attr">only:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">docker:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">circleci/node:10</span></span><br><span class="line">      <span class="comment">#免费类型的，只能使用一个容器</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">checkout</span></span><br><span class="line">      <span class="comment"># checkout把gh的项目检出，详细参见：https://circleci.com/docs/2.0/configuration-reference/#checkout</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> </span><br><span class="line">          <span class="attr">command:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">sed</span> <span class="string">-i</span> <span class="string">"s/GH_TOKEN/$&#123;GH_TOKEN&#125;/g"</span> <span class="string">./_config.yml</span></span><br><span class="line">            <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$GH_USER</span> </span><br><span class="line">            <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$GH_EMAIL</span> </span><br><span class="line">            <span class="string">sudo</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-searchdb</span> <span class="string">--save</span> </span><br><span class="line">            <span class="string">sudo</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-wordcount</span> <span class="string">--save</span> </span><br><span class="line">            <span class="string">sudo</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--save</span> <span class="string">hexo-blog-encrypt</span> </span><br><span class="line">            <span class="string">sudo</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">            <span class="string">sudo</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span> </span><br><span class="line">            <span class="string">sudo</span> <span class="string">npm</span> <span class="string">i</span> <span class="string">-g</span> <span class="string">yuque-hexo</span>  </span><br><span class="line">            <span class="string">sudo</span> <span class="string">npm</span> <span class="string">install</span> </span><br><span class="line">            <span class="string">sudo</span> <span class="string">yuque-hexo</span> <span class="string">sync</span> </span><br><span class="line">            <span class="string">sudo</span> <span class="string">hexo</span> <span class="string">clean</span> </span><br><span class="line">            <span class="string">sudo</span> <span class="string">hexo</span> <span class="string">generate</span> </span><br><span class="line">            <span class="string">sudo</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure>
<p>以上做好之后，在gh这里有新的push的时候，CircleCI便会自动构建项目了，同时部署你的hexo网站  <br>后面争取做到在语雀编辑好文章的时候触发自动build</p>
]]></content>
  </entry>
  <entry>
    <title>chrome离线安装包下载</title>
    <url>/2019/03/26/yuque/chrome%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>如果您要为单个用户帐户安装Google Chrome：<br><strong><a href="https://www.google.com/chrome/eula.html?standalone=1&amp;platform=win" target="_blank" rel="noopener">下载Google Chrome离线安装程序（32位）</a></strong>—&gt;<a href="http://u19829043.ctfile.net/fs/19829043-357598048" target="_blank" rel="noopener"><strong>国内点这里</strong></a><br><strong><a href="https://www.google.com/chrome/eula.html?standalone=1&amp;platform=win64" target="_blank" rel="noopener">下载Google Chrome离线安装程序（64位）</a></strong>—&gt;<a href="http://u19829043.ctfile.net/fs/19829043-357597925" target="_blank" rel="noopener"><strong>国内点这里</strong></a><br>如果您要为所有用户帐户安装Google Chrome：<br><strong><a href="https://www.google.com/chrome/eula.html?system=true&amp;standalone=1&amp;platform=win" target="_blank" rel="noopener">适用于所有用户帐户的Google Chrome离线安装程序（32位）</a></strong>—&gt;<a href="http://u19829043.ctfile.net/fs/19829043-357597726" target="_blank" rel="noopener"><strong>国内点这里</strong></a><br><strong><a href="https://www.google.com/chrome/eula.html?system=true&amp;standalone=1&amp;platform=win64" target="_blank" rel="noopener">适用于所有用户帐户的Google Chrome离线安装程序（64位）</a></strong>—&gt;<a href="http://u19829043.ctfile.net/fs/19829043-357596415" target="_blank" rel="noopener"><strong>国内点这里</strong></a></p>
<p>2019.3.30  当前最新版本： 73.0.3683.86  国内共享文件解压密码为： areuok</p>
]]></content>
  </entry>
  <entry>
    <title>k8s  共享内存的实现</title>
    <url>/2019/03/19/yuque/k8s%20%20%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><a name="a5444275"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Docker默认共享内存是64M，并且可以通过<code>docker run --shm-size</code>进行修改，Oracle的镜像在docker运行时候可以通过 –shm-size  指定共享内存的大小，在k8s中没有这个参数可以使用<br><a name="c989a51d"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在k8s中，没有参数可以直接指定变量，只能通过变通的方式实现，查看k8s卷的说明，<code>emptyDir</code>支持<code>Memory</code><br>，可以将该<code>emptyDir.medium</code>字段设置<code>&quot;Memory&quot;</code> 告诉Kubernetes安装tmpfs（RAM支持的文件系统）,配合deploy，可以实现在pod使用共享内存超出限制的时候驱逐pod<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/dev/shm</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dshm</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dshm</span></span><br><span class="line">  <span class="attr">emptyDir:</span></span><br><span class="line">    <span class="attr">medium:</span> <span class="string">Memory</span></span><br><span class="line">    <span class="attr">sizeLimit:</span> <span class="string">"300Mi"</span></span><br></pre></td></tr></table></figure></p>
<p><a name="db06c78d"></a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>部署一个deploy-&gt;生成超出限制的请求-&gt;观察pod的events  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deploy.yaml </span><br><span class="line">kubectl get pod -o wide # 查看pod所在节点   </span><br><span class="line">kubectl exec -it xxxpod  bash #  进入容器生成文件  </span><br><span class="line">dd if=/dev/zero of=/dev/sdb bs=1300M count=1</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1552982838373-4be954c8-5e4a-4bab-ba56-dfc4d24c5c59.png#align=left&amp;display=inline&amp;height=188&amp;name=image.png&amp;originHeight=188&amp;originWidth=1083&amp;size=34483&amp;status=done&amp;width=1083" alt="image.png"></p>
<p>参考:  <a href="https://kubernetes.io/docs/concepts/storage/volumes/#emptydir" target="_blank" rel="noopener">Volumes</a></p>
]]></content>
  </entry>
  <entry>
    <title>说给谁听</title>
    <url>/2019/03/11/%E8%AF%B4%E7%BB%99%E8%B0%81%E5%90%AC/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">来了老弟，记得你的生日~~</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="762e70371e5e2727b945cd6ba091dfb27398f260685b63e5e10a2d78629f36dc">3ecbda1feeff016ac4b4101df33314c80c997ae8139b51568e0d2c945992890dc7fec1ce48d214cf94bf95ffe73e5beb84b4ff9ef48dc0600e363a100853d1f92b99ba08c00f23a8a4e41d8dd67e445cfaad3822db836755ca2a57be62204afb5f976d356f203ef18f232c65dacf862a6d5553d3e84b5e4e19b8d734cecb69e9b45bae233890138c51c979825d1a0b7dce39991c50d72dd14448de60e960c76ac7c77d1235f52dedf34920df11c249b83b17e561a16de460d154871f269edb3ea4fcc1ce1f4368d67cde51d787f591b6e3b6134733a38d2ca3038f8017092e13937fbb991df8e34e568347b259bd9c926f58f0d53e84494e39207561faeca3f10a86bf746af8c3dabc51e03dd5c268ca9f3f3a65b713a5a8cfaa8f1c2171c496e422f85ece5686e4b1189934b86cc45dd91e15933ecbd64f4c2bdeb4c981405e70f1643684885f67072f50daa8e37972128ecedb360fbb7a506ec79df4f748e5b29e83f68741bc68af52bbe9c349970cfddbeae3b1894a938f4bae6778df7940a9b1cf5e6e710e76d2e6bc60646627d99c54a93d42ad70f151c0fe493f55da3a8b688185d084343b34b43e85f813436dc1d882eebfa17ff3e5db053a42e17a658bdc85aab4a16a62cdd9bd9e912d9903b1f28d0c46b4e96b182ed23a6f0ae238f526ba24a3fe5084625303f8ea04a18ad2627ec6a68aea4fab75e90a8f19f3d2c895d88f9268bfd8ff7ada0cdd46b38c532fe4f34bdea1869850463f142c1c71894255cb3eb60b82f0d1d64c5b6cd67d92bf29a06d79a666834b50401dac7d1b7a3a04629196856ba67d288fb26fd0f8d5ba2dbb56fed9640d0a59b5853a1ccb060378b8a15d193604c26de8964080851c4559a12c6730e90d8461e92f8316e672a8aa5a40049602f37dcf5c7b361051578f8bdd73f29d3503ade7168f758f490de1c8ca1d98341d4db3a9a301e8018c6823d57bc56680c1b93add850ccb4172c3c96772ae0cd87d245f1c3e9e7fb47fc12fd53cb4cb721b130e03de069fbfc50b778c3414dc44bf3db65bab59d9c53c0a27bb0fe108f68c6d04897938541f99507366b2536c9ffa4b46367bcdf60d21fb8b54583db16cd2840632136075b537b8a1451bc30acf69dc61943cae319a72a1b7aeb81b5a2f62f6663914fc60353485aae984e840afb7ec1787c8d208e4222801c87a215da6a4645b01e2be07d9f2f70c42b9d1bae8ee23dfa98ed9d538d4ba96eecb649c54f348fbeea2237e03928bd09e12245f92fa71178cb4adef08c3cbb6aaf4ecd3fe429107112db3f21332ba7accbb039dc49137813b9f776ec87ce0a742f90eeddb28614e44b1c427be0013d82f620f741e0546da836cd884c63612e4ea811f9873c670771b2bca706e84cecaf7938223dde034fb4707352b27c37e48376c47c793e12805485c72a62a1eda3434dd01615e9f62bfd183a402e6d75a6834300b3fb8d11bbc1951906a34692609b1170f904140743b6d2f85ac084fd7876e0abfc62ecfe2c719fb47c3871d8454dc0866205edf5d68d9a278908e7722a670d5cdb3fa400dfd0ce95470dd6c678f89f2e71ae9ab7260324b3981791810a32352334f110e2bbee3e807a8770aed11b5c8f11a2427c043b791829786004a2ab0ad8da71c2e853c6140a15b9f682d3d32d0d00964e47c1285e432b39c90247295539a89e1ab179ed4d46897768c5625d2cd649afdc72dde30993bbf23e6c67cb280e1d79f681229748f5c8ad4d1a4b1ef51a2d5efd1dba29e4cf6ada7a1b060ca4ffa3f4ffd287f8eb1d08498fe9516e683cdb4504c50fad10e48538fad82dfb2c395f4865992b01d4e3cd9bf30572587d6215aadc0b4361dd8143745723e1b27700e634cb6dc56f2f8c18cd7643852408737accfb88c43dc40d1636dc0750aa239d4484b82570937b853b9397b6e9aeb50040683cdf3893b77dd9c047e5d8c685732d29e8a0067149db655047b8c3a4581347017b173e93be4bdcbafb20216710237a2c92c11c3a3550c09dd7cef0c525c4e3d5aaac0040cebd82665692969d6ec0ced73af14be149d29b74010d1790114644c94cd8c090f2ce5fff0c7c14d6cbed945452e20811aab7170ceb6624495446bf27ac3e576b1659f342593296f5de93e82863fa69b77bab5103765d4459377558a131e52043ffae905dec3fa093bc7cfdeb563ea51909873183f37a8a1d5006c6adefc98c8e379861b6bf4456cbde832281d92697329b773bdb51ff3482fe114d476e88699e2e6cf76e376783da2a662889194bb4000d739c152ff424e57d093e8d5040d1a65559d2fcf17c15a4be8582cfd256eabadce5b842c9d4039dd05900dec1982afd1db096d1f51035baaa6fa9a49b4a1f733ea604251b4015786d56401de5c61611517d81257224a6887e919f625ae6f91a4b776ef88cd494d710a894f838344122d34a2221eef24fc0a753557b3e984a11f95e60aa260834662de1278b7b8916ad107d15f9fb4ca47758ea1b8e8e2b6804a5df580712d88c21278302b2e39faed092b493dbe994885075abbf3c211d7124d417e68d09d87828ab62a132c9f08ff8d8a910a8a1042558832ff96bb044c55f0616edf4e3910dd7861f5947b3e4fe8f195c4580d25a0074c45a80d4e9eead82be4c46f58d7a2e28e6e07d465d6069fe1753279fee9fa7c469c51b169690e610e4830aba7079cdb86860c6be45d984e60c96f9ae2e4815a37de95233ecf9cae4b146315e4df89387ec96f8bfde26313ce594ac4cf368aaeb0c953522e09af216c0ae9eb40ddb09c63f4fd5f9e87579d3a05d53f7424ee9e58b7baaec061dcec0ad75f56759037782ade65e10e1f22449cedb68e47bf2fa6d3bca5853e7e656b4613c2544cfa82223925e43ffad766ffc222f0dbcf3eea59be9980e63d600f88127a6f14146fb8ecc9ab7cd32a7a1d7e11502f50ddf13668574d088371d7a7a9e4a14842d313a03e122ddef4bb68c19d05fa1085975523cbbd825f16cf3840dfea415743f9e8fb28cb37345e546d2d8e276e41745637ea796b30d2566d6bea8dbb94c33bcfbf92f136e5db568548b47f6da761f66987362269c11103a79c59a19a6d75860d0b0fced870f636dc86e4cc9f48fa4ba045fbdced3d8a3acf63e113b1b0de9ea9319e5faa6d8a5be2781940739c4f2c971c07d69a009510cbd88b47ee97cbb8abba36554c371980d90bd42500936a287c0a6ab88906357aff7295f5a099d91a6e814372e7f68b2331b4c3933c53cb9f607d4ffdd09e000932e8768e98d8a97bc78a834459d401eda9d8369694f815481adec99be011440b6f4009e5b273eb683cbdac299ed75f59b14c9eeb103223cc7555c5759c0237876e916ab89bd5268985183a8da69ae6d3b57e0d22b9784fb219f7705061c077cbe9d6b3d349a60754e11acd01f1edace214c0a65c8c56313109e3f486de2b2e1a66ab118e6c30354655e4ed2a263a10deef747219875042fc610f23ea98691a55b3e06b777514cc07d4e2e9a0b1e65a5c4d0b1caea4d2207c82bd8c5c7757eaef5e038165647ed086d424f21321136e438e5b9679c2f9d62bc47892d9cecbce73deaf3cee21c502c95a3e8648cbfd55c66ea7ab20109a55754381d863636308e169a62448b478542c585611908207a8c52571c4817db90ae89a72cfc11594bf676ad47552d39bc4e6b69334fdcd7a89f52f6cafcc042b48fde307a24cdd5ae35e4209f23c0ee09659c221f280421514cdf65872491d8dbd7abf68dfc4c3f6d8893308f544d0fda9a17183ae961d85ce409e68abb9ff7919d5f16c0f9574270017dddd4ca5b46ea1f59affd40995dd44011168f163eafcd9376ec29afb44743c85ced7165e1e91ebe03ae7dec56b2758c70f89596af407f02ec8b8800de69406356153e1b1d37d27e6ae64dd1bf17dd5db0776c754a00b29d23508415a5d16c8ace142cdb4207283f98b16852a55ac26c128148761788e2e4b8d71a8185bdc7209448cce3a7c79030f4e863e7679a9ff143e21652d867c0b1eac201f8e77055d3600a183c2d31a2b80b0f4f4da73502b74adda6df025b3071445a15019b3f9a6681a893467c725fbd5cc439be2ab523eb81abc20345932d537a1760072169a4d000e7463559d56f8c3547cce3c59cd9ae700f34078c207068901bc673097f283348602cabd20f8518b25bfa46076f9b1e48ea61ddf0127c68f344c28b7f974d29778fcace5d59e0216ba5d0f991e561976c0dcb6c6aca39a67449e7bd295bf38475ee4752bdd9a515047e524a175d4b407bf8e1e88538dc169dfa9be6e6ca70eb1bc4e5124ee8cdf34c3cde9b57c6ff33e33814cf3a06dd7aa23fb9f961597835f2f5dada544add530714e09d7b1bed234f3c8fea8dc7e2e04f503807b882517a0f06b538907a20006100d6438ab5b73b18eae5f6515640fad77d94f6cf6565f24238c4f12af1f57995d595e55f7b1876c81f7262054d2f282f2149c2efc391c2f98b14afaa6c6925eef3e17d39a4cdea4fede57ce55d334a3d4740f042d351badafb432278477edf25e2a30735a8f7c864aad97689f70fd1602f1d0c5cb3fe6bdfccc4e67d6decd8111e3ff88697e0971de1a4e002601dabd46ec5ed66172e5bfb4c0607a6987624e4cac1069913417fe3f003991377add8e2fe99d2c9e644f664c861e5b180211d52b9b13452c929801812040e80c83ed9169d6b758993a93b372723525c059dcdd614d233c657726a8b2396bba758658f4dc991892b10b11fd8d1ab1ab5ca6a9e1de09233a21ff80436a7fc4f7769631fcd882852b10026c215992d57ecd3fdee5d5d6851e4e68a1f9b47bc790aca2e14c1ef1fb0d0f4c6487367b4adb94fbd06b29d3e9896379c914ef0dfd23a11e6298d70be0d3db3409bce1460379e485ae734ee606b611c6e5d762bdcd3835eb3ee23241c7569bdd8e4c73b2b3644729b9c39e0cc42c5d43a790f61b20add2e0bff7ce95069d734a1d02b4cf178a0d08e5fbd3dcd19cb3abb9ff054ddd95e0a58e4c7777cfe23ba1627d069b446f102566928069a31b0e6d6360e30d916fdde1838c6cf5ad4643847bd18499b52a08bead5926a20c4f4ad5fe4e21c588c2f2ae303c0813110211eca7cc8fe1f00f90f3cf738358902722577a351628bd1004bd0e15ec16bf6e5738c91d855e5aca8cc272513f94d7505adfca7657cfde16310142e9c520205d1c1b936a7df82ca4036a75c457d4ba481652070f4c370ef16d7f7360964b6316c6896efcc56ca422b462f770905f6700be19c4545e08cf73b0745fb24e6267a0e0849892298efb50e6a2bef80c942593201604c722148b89bdb7e0a08364dfe1d05c35ac362658c70ffbf5cc0a098a258e96cfc5d0403458d409e2346a1e87088a2428a8ac74e8bd8c78b3558ccb7dd514c7e2f80fa04d1ab9bdad244fd9bc77eefbe5f30f11266cda6f5195bd213e9acc1613ce1b74b0c9d838b664a09f8585aede23e6457ad980e10c748cfbfbae35e8f783b018a8a73b3c9643ceb29d63c865a196523a5592015f9b55082995bfc07cea73625286be6fdf2709d62995c8b9c84b909f3a2f8138b8ee788a9e8381a33e2674e3de66bc499054d2e7aef8ae8ee3062553eb4d3675b20982b673f72ce22c2a143bbdd13454958d72e39e02141a19efbc68634eb5989acb15cda8a7a094046d9a72636961fa3b14edc548041904ff73724e07a15d870d73cc613810cde37cb026deeebb9442639b0faae48e02d469c1de34e56bfb006a0a6d137105801132dd66687a103e1a2fd3793e3f1bc5b1ea53d1c021d894b167efc391fddea8d2c73f670e51ea7ba4e810796182c4d288eadc23668bf5f2d35d7b0c45e9a6f751264dd6526a03d906fc3328d49acee1d8eb356170aa65e4564abf171c4e0cb3bfea1fa9c35890dde71110d79ad9c2adea5af009f4269f4aa0111b4b97105fd3f1cbcc3bc4ee0240580c614277a9b1df222cea935880ca5fbac6660e344be7e3bcd2eba6d5236ec3041926fd8c07a0a9bc59ff84d0a498cc343ef032f0b48208d6fc49ac9224cac2d00034bce27643cfa978d15d73caf78e37aa4c9860757e4ad820d8268ec5840d78fa22ae5301378338b12d2bfe859cd58d81b4f62384f19d074e994be70e69a2378ea087fc05bf0a37ce571f5303cfd14831cf483a377cfa1bc27f2c471d23bb80d60bdf2c547d8a2c3018a2c191cbc1555fdf95f3cbd3f131228b3291f546ceebfcaa42b5469bac138d122f6cc2e7bf7510c00773986a3d77167a9b49976cc5d1f45abf19fd82fc6f707326497c6c999f0cd3d571680f40a982734ab81334ce82a9730ee81a2d8a99bb952ae32a7fc192d189329381999f9112eca828c3b9ad8259cfb8b44bc5aba5cad8c1563f98c61169e02666c9537326a7be39225030ae8a5af5352943269672ab6e549c1923f9f9ff0b6075212137008f79696d2df41a69ff7f7b9548d28ebe7bc727b04b14b5624841d2dab6a873ab50b8ed21c66a1cf3b04900fc93a9af586111dcc1c3e11497edfa340f13a3a30a82eae813d208c0456da4f854899c0211e0a45dce17ee601441b0296c863f92ac760409d01f0eaf0154dad509dad871c1e64bc204d9b23515970dffe134d32a4add517666b048e5ce1a588641571491a2e1c35282733c1a58e05d6b8a8d471535421395f4a13c4e94be6339d9003c12b646c6ff6a6dfcc97baf6a03ff52d4ef42cfeec1fa6afb72556873fb6bb4084e10c7ea05f037dafcdfabe30129a9b186f819ce959b3948d468bcd45b2be4705b7b6dd313d2508988e74ffb634439be41de2e04886707b97437ef041f9ee5b5f4590bb02199aab47efa41d8c93afffa6f38f62bf7889dc447bd803efb2adf09c710dfb6bf8d31b90fce91abfafe90af774c609d18530560356e2581d0b479c8bd56a31fc96aef73becadb56ef3e11f612ca97a4dc9a4165cd5f56239d57ab36001211c8603800671260198c436fdf59bcc1a9e8919717444d83baec8175d5b048eff462036f19e83af877127bb2ce4d0c2232798286a7d5894e29061bb977270b376124f7174e118e363bcffcf78c1e3a8d234b241580746594839fc487ef37925925158029b6e8e7cbe430589ad4e37557f9b9e299f3da20e648e83a99590abb48c5146e288e5e484519b7d6180c39ffc54114f74a945b17cbf436653e2bc2ff8f85233b7f85ea40c944f9cb4950d31bbfd67409f367dcad56c30c8e3564e45d548de82586928e7b863a533555db0dde41a37020d06a56507d8778da73bb8be69ba831a2b95a0aa58f2fe125c596f87ce729db7679c13597e66b3a04368a12a8f88bb070c6441645a5509f354b0bdd78b6316d4c43b7d74dcc2fb0b547dbc9ab42b371de4c91f6dccc49d691eb65fe0712b7b31aa2ea1076ce9fc7013a6932c993f5d80b39c8c3fb00c51b9f0cc93ce7d46e83ba78a6bddb3e6b4d6bd52cb4861299ac129b92d2022bf66f3569862b7b1ccf95e4e0fa98bcd51b5e93af713ebf98687befab2ca2d610b69c6eef2f4c05432ad1ffeb6ad47b721ded81d2db5e3b1620e1bdd7e6a3bc87403e66c91346a98037ed773ca56b1e8b5a21e58921d9820674957e6fdc176db7b7a655f4354440381a02366043d20bee5446c52d89f5491e145b7f5a045084d828308a423aee81ed316fed1dc4aff85b2eb20d4a8811a03566a5f95bc7742923b81c51d51db096e329ee71179f3f957d6b572cc65d8ea67d0f70a0dbefdb653d4b98c7733ac2f863a34555930da3b2dec6a1cc3deadec950e5dc1c44072d0550abdafa8b04fe7e947958091cb857c274823c04374efc108f359e38b33027f106f08b5ca4c951e78aaee63074ef68ab770404de88e7b52182854204ce4b7e80996fe04e3491b1e34729884b10f90030c5b0c424d6a9a2f4f240c01771caf5dff2ca4099b5bb557dbdd95b810ba7cf775f9310c88b2559</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>myself</tag>
        <tag>only</tag>
      </tags>
  </entry>
  <entry>
    <title>pod 一直terminating 状态的处理</title>
    <url>/2019/02/25/yuque/pod%20%E4%B8%80%E7%9B%B4terminating%20%E7%8A%B6%E6%80%81%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>使用<code>kubectl delete pod xxx</code>后查看pod状态一直处于terminating 状态，使用<code>kubectl delete pod  --grace-period=0 --force</code>可以强制删除pod，但是k8s不会检测是否pod真的被终止了，可能pod会无限期的在集群中运行</p>
]]></content>
  </entry>
  <entry>
    <title>vps 端口被墙的解决办法</title>
    <url>/2019/02/11/yuque/vps%20%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%A2%99%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><a name="df45c20f"></a></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>自用的vps突然连接不上外网了</p>
<p><a name="77283881"></a></p>
<h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p>检查vps，ping检测:<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1549851707952-db9b149c-45d7-40a7-b86c-377f5e6ace54.png#align=left&amp;display=inline&amp;height=148&amp;name=image.png&amp;originHeight=148&amp;originWidth=602&amp;size=11141&amp;width=602" alt="image.png"><br>端口检测： 推荐： <a href="http://port.ping.pe/" target="_blank" rel="noopener">http://port.ping.pe/</a><br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1549851239305-8c7a5e66-e6fb-47bb-8bd6-0b8a602672a9.png#align=left&amp;display=inline&amp;height=821&amp;name=image.png&amp;originHeight=821&amp;originWidth=1268&amp;size=142735&amp;width=1268" alt="image.png"><br>可见，vps对应的端口在国内被封禁，此种办法一般修改一个端口即可<br><a name="4b86211f"></a></p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在sspanel后台管理处修改对应用户的端口，重启ss服务端<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1549851351485-3719ea09-7cfd-4fb4-90bb-94ebb79ea2e7.png#align=left&amp;display=inline&amp;height=484&amp;name=image.png&amp;originHeight=484&amp;originWidth=1082&amp;size=29647&amp;width=1082" alt="image.png"><br>再次检测：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1549851420075-201ac656-b419-4244-955c-adba66332f3b.png#align=left&amp;display=inline&amp;height=837&amp;name=image.png&amp;originHeight=837&amp;originWidth=1281&amp;size=150296&amp;width=1281" alt="image.png"><br>所有访问点，端口正常通信。</p>
]]></content>
  </entry>
  <entry>
    <title>k8s DaemonSet 介绍和使用</title>
    <url>/2019/01/29/yuque/k8s%20DaemonSet%20%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>一个<em>DaemonSet</em>确保所有（或部分）节点上运行pod的副本，随着节点添加到群集中，将添加Pod。随着节点从群集中删除，这些Pod将被垃圾回收清理，删除DaemonSet将清除它创建的Pod。</p>
<p>DaemonSet的一些典型用法是： </p>
<ul>
<li>在每个节点上运行 集群存储后台daemon，例如glusterd，ceph。</li>
<li>在每个节点上运行日志收集守护程序，例如fluentd或logstash。</li>
<li>在每个节点上运行节点监控守护进程，比如  <a href="https://github.com/prometheus/node_exporter" target="_blank" rel="noopener">Prometheus Node Exporte</a></li>
</ul>
<p>在一个简单的例子中，覆盖所有节点的一个DaemonSet将用于每种类型的守护进程。更复杂的设置可能会为单一类型的守护程序使用多个DaemonSet，但对不同的硬件类型使用不同的flags 和/或 不同的内存和CPU请求。</p>
<p><a name="d9a9cb0d"></a></p>
<h2 id="编写DaemonSet"><a href="#编写DaemonSet" class="headerlink" title="编写DaemonSet"></a>编写DaemonSet</h2><p><a name="19f878c2"></a></p>
<h3 id="创建一个守护进程集"><a href="#创建一个守护进程集" class="headerlink" title="创建一个守护进程集"></a>创建一个守护进程集</h3><p>在yaml文件中描述daemonSet,一个运行fluentd-elasticsearch Docker的yaml文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd-logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">k8s.gcr.io/fluentd-elasticsearch:1.20</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker/containers</span></span><br></pre></td></tr></table></figure>
<p>基于YAML文件创建DaemonSet: <code>kubectl create -f  daemonset.yaml</code><br><a name="14d637d5"></a></p>
<h3 id="必填字段"><a href="#必填字段" class="headerlink" title="必填字段"></a>必填字段</h3><p>和其他所有Kubernetes配置一样，DaemonSet需要apiVersion，kind和metadata字段<br><a name="52361096"></a></p>
<h3 id="Pod模板"><a href="#Pod模板" class="headerlink" title="Pod模板"></a>Pod模板</h3><p>.spec.template是.spec中必需的字段之一。<br>.spec.template是一个pod模板，作为一个pod，他有完全相同的架构，除了没有apiVersion或kind，因为他是嵌套在daemonSet里面的模板。除了Pod的必需字段之外，DaemonSet中的Pod模板还必须指定适当的标签<br>DaemonSet中的Pod模板RestartPolicy必须为Always，或者未指定，默认为Always<br><a name="c6a7f07c"></a></p>
<h3 id="Pod选择器"><a href="#Pod选择器" class="headerlink" title="Pod选择器"></a>Pod选择器</h3><p>.spec.selector字段是一个pod选择器。它的工作方式与Job的.spec.selector相同。<br>从Kubernetes 1.8开始，您必须指定与.spec.template标签匹配的pod选择器。当为空时，pod选择器将不再默认。Selector 默认与kubectl apply不兼容。此外，一旦创建了DaemonSet，其.spec.selector就无法改变。改变pod选择器可能导致Pod的孤立，并且发现它对用户来说是困难的。<br>.spec.selector是一个由两个字段组成的对象：<br>matchLabels   – 与ReplicationController的.spec.selector相同。<br>matchExpressions  - 允许通过指定键，值列表以及与键和值相关的运算符来构建更复杂的选择器。<br>指定两者时，结果为AND<br>如果指定了.spec.selector，则它必须与.spec.template.metadata.labels匹配。具有这些不匹配的配置将被API拒绝。<br>此外，您通常不应直接创建任何标签与此选择器匹配的Pod，可以通过另一个DaemonSet或通过其他控制器（如ReplicaSet）创建。否则，DaemonSet控制器会认为这些Pod是由它创建的。Kubernetes不会阻止你这样做。您可能希望这样做的一种情况是在节点上手动创建具有不同值的Pod以进行测试。<br><a name="18e8ac9e"></a></p>
<h3 id="仅在某些节点上运行Pod"><a href="#仅在某些节点上运行Pod" class="headerlink" title="仅在某些节点上运行Pod"></a>仅在某些节点上运行Pod</h3><p>如果指定.spec.template.spec.nodeSelector，则DaemonSet控制器将在与该节点选择器匹配的节点上创建Pod。同样，如果指定.spec.template.spec.affinity，则DaemonSet控制器将在与该节点关联相匹配的节点上创建Pod。如果您未指定任何一个，则DaemonSet控制器将在所有节点上创建Pod。<br><a name="3ed57661"></a></p>
<h2 id="Daemon-Pods如何调度"><a href="#Daemon-Pods如何调度" class="headerlink" title="Daemon Pods如何调度"></a>Daemon Pods如何调度</h2><p><a name="6ee2fd52"></a></p>
<h3 id="由DaemonSet控制器调度（默认情况下自1-12起禁用）"><a href="#由DaemonSet控制器调度（默认情况下自1-12起禁用）" class="headerlink" title="由DaemonSet控制器调度（默认情况下自1.12起禁用）"></a>由DaemonSet控制器调度（默认情况下自1.12起禁用）</h3><p>通常，Pod运行的机器由Kubernetes调度程序选择。但是，由DaemonSet控制器创建的Pod已经选择了机器（在创建Pod时指定了.spec.nodeName，因此调度程序会忽略它）。因此：</p>
<ul>
<li>DaemonSet控制器不遵守节点的不可调度字段</li>
<li><p>即使尚未启动调度程序，DaemonSet控制器也可以生成Pod，这可以帮助集群引导程序<br><a name="455103af"></a></p>
<h3 id="默认调度程序调度（自1-12起默认启用）"><a href="#默认调度程序调度（自1-12起默认启用）" class="headerlink" title="默认调度程序调度（自1.12起默认启用）"></a>默认调度程序调度（自1.12起默认启用）</h3><p>特征状态：Kubernetes v1.13 beta<br>DaemonSet确保所有符合条件的节点都运行Pod的副本。通常，Kubernetes调度程序选择Pod运行的节点。但是，DaemonSet控件是由DaemonSet控制器创建和调度的。这引入了以下问题：</p>
</li>
<li><p>不一致的Pod行为：等待安排的正常Pod已创建并处于Pending状态，但DaemonSet pod未在Pending状态下创建。这使用户感到困惑</p>
</li>
<li>Pod抢占由默认调度程序处理。启用抢占后，DaemonSet控制器将在不考虑pod优先级和抢占的情况下制定调度决策</li>
</ul>
<p>ScheduleDaemonSetPods允许您使用默认调度程序而不是DaemonSet控制器来调度DaemonSet，方法是将NodeAffinity项添加到DaemonSet窗格，而不是.spec.nodeName项。然后使用默认调度程序将pod绑定到目标主机。如果DaemonSet pod的节点关联已存在，则替换它。DaemonSet控制器仅在创建或修改DaemonSet窗格时执行这些操作，并且不对DaemonSet的spec.template进行任何更改。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nodeAffinity:</span></span><br><span class="line">  <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">    <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">matchFields:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">metadata.name</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">target-host-name</span></span><br></pre></td></tr></table></figure>
<p>此外，node.kubernetes.io/unschedulable:NoSchedule容错会自动添加到DaemonSet Pods。在调度DaemonSet Pod时，默认调度程序会忽略不可调度的节点。<br><a name="eb1dd5c2"></a></p>
<h3 id="污点和容忍"><a href="#污点和容忍" class="headerlink" title="污点和容忍"></a>污点和容忍</h3><p>尽管Daemon Pods尊重污点和容忍度，但根据相关功能，DaemonSet Pods会自动添加以下容差</p>
<table>
<thead>
<tr>
<th>容忍key</th>
<th>操作</th>
<th>版本</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>node.kubernetes.io/not-ready</code></td>
<td>NoExecute</td>
<td>1.13+</td>
<td>当存在诸如网络分区之类的节点问题时，不会驱逐DaemonSet pod。</td>
</tr>
<tr>
<td><code>node.kubernetes.io/unreachable</code></td>
<td>NoExecute</td>
<td>1.13+</td>
<td>当存在诸如网络分区之类的节点问题时，不会驱逐DaemonSet pod。</td>
</tr>
<tr>
<td><code>node.kubernetes.io/disk-pressure</code></td>
<td>NoSchedule</td>
<td>1.8+</td>
<td></td>
</tr>
<tr>
<td><code>node.kubernetes.io/memory-pressure</code></td>
<td>NoSchedule</td>
<td>1.8+</td>
<td></td>
</tr>
<tr>
<td><code>node.kubernetes.io/unschedulable</code></td>
<td>NoSchedule</td>
<td>1.12+</td>
<td>DaemonSet pods可以通过默认调度程序容忍不可调度的属性。</td>
</tr>
<tr>
<td><code>node.kubernetes.io/network-unavailable</code><br></td>
<td>NoSchedule</td>
<td>1.12+</td>
<td>使用主机网络的DaemonSet pod可以通过默认调度程序容忍网络不可用的属性。</td>
</tr>
</tbody>
</table>
<p><a name="d41d8cd9"></a></p>
<p>###<br><a name="c7c4ac4e"></a></p>
<h3 id="与Daemon-Pods进行通信"><a href="#与Daemon-Pods进行通信" class="headerlink" title="与Daemon Pods进行通信"></a>与Daemon Pods进行通信</h3><ul>
<li>在DaemonSet中与Pod通信的一些可能模式是：</li>
<li>推送：DaemonSet中的Pod配置为将更新发送到另一个服务，例如统计数据库。他们没有客户端。</li>
<li>NodeIP和已知端口：DaemonSet中的Pod可以使用hostPort，以便可以通过节点IP访问pod。客户端以某种方式知道节点IP列表，并按惯例了解端口。</li>
<li>DNS：使用相同的pod选择器创建无头服务，然后使用端点资源发现DaemonSet并从DNS检索多个A记录。</li>
<li>服务：使用相同的Pod选择器创建服务，并使用该服务在随机节点上访问守护程序。（无法到达特定节点）<br><a name="1061b80e"></a><h3 id="更新DaemonSet"><a href="#更新DaemonSet" class="headerlink" title="更新DaemonSet"></a>更新DaemonSet</h3>如果更改了节点标签，DaemonSet将立即将Pod添加到新匹配的节点，并从新匹配的节点中删除Pod。<br>您可以修改DaemonSet创建的Pod。但是，Pod不允许更新所有字段。此外，DaemonSet控制器将在下次创建节点（甚至具有相同名称）时使用原始模板。<br>您可以删除DaemonSet。如果使用kubectl指定–cascade = false，则Pod将保留在节点上。然后，您可以使用不同的模板创建新的DaemonSet。具有不同模板的新DaemonSet会将所有现有Pod识别为具有匹配标签。尽管Pod模板不匹配，它也不会修改或删除它们。您需要通过删除Pod或删除节点来强制创建新的Pod。<br>在Kubernetes 1.6及更高版本中，您可以在DaemonSet上执行滚动更新。</li>
</ul>
<p><a name="d17a0f0b"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/#" target="_blank" rel="noopener">DaemonSet</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用kubeadm创建一个高可用的集群</title>
    <url>/2019/01/20/yuque/%E4%BD%BF%E7%94%A8kubeadm%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p><a name="1aaf0cc7"></a></p>
<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>需要事先准备好haproxy环境和keepalived环境以及容器运行时（参考<a href="https://kubernetes.io/docs/setup/cri/" target="_blank" rel="noopener">这里</a>），同时满足以下最小配置的需求<br>  至少2G的内存和至少2核的CPU，关闭swap，kubelet必须在swap关闭的情况下才能启动<br>关闭指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>
<p><a name="146efe0c"></a></p>
<h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><p><a name="cf49352e"></a></p>
<h5 id="k8s组件准备"><a href="#k8s组件准备" class="headerlink" title="k8s组件准备"></a>k8s组件准备</h5><p>首先安装kubeadm  kubelet kubectl  ，我们这里使用阿里云的源来安装，所有的节点都需要这个：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">setenforce 0</span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure></p>
<p><a name="16e3ab9f"></a></p>
<h5 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h5><p>kubeadm的安装方式，把k8s的主要组件，kube-apiserver,kube-controller-manager,kube-proxy,kube-scheduler,coredns,etcd,pause这些组建的都通过镜像使用静态pod的方式启动。首先我们这里要准备好镜像，以便在初始化的时候，加快部署方式，同时排坑。如果你的环境可以访问谷歌那么可以直接通过命令下载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果你的环境可以访问Google，那么可以通过以下命令下载好所有的镜像</span></span><br><span class="line">kubeadm config images pull</span><br><span class="line"><span class="comment"># 如果以上命令执行失败，那么可以使用我准备dockerhub上的源来获取</span></span><br><span class="line">cat  pull_from_docker_hub.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">KUBE_VERSION=v1.13.2</span><br><span class="line">KUBE_PAUSE_VERSION=3.1</span><br><span class="line">ETCD_VERSION=3.2.24</span><br><span class="line">COREDNS_VERSION=1.2.6</span><br><span class="line">GCR_URL=k8s.gcr.io</span><br><span class="line">HUB=imdingtalk</span><br><span class="line"></span><br><span class="line">images=(kube-proxy:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-scheduler:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-controller-manager:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-apiserver:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-proxy:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">pause:<span class="variable">$&#123;KUBE_PAUSE_VERSION&#125;</span></span><br><span class="line">etcd:<span class="variable">$&#123;ETCD_VERSION&#125;</span></span><br><span class="line">coredns:<span class="variable">$&#123;COREDNS_VERSION&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull <span class="variable">$HUB</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker tag  <span class="variable">$HUB</span>/<span class="variable">$imageName</span> <span class="variable">$GCR_URL</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker rmi <span class="variable">$HUB</span>/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 以上，即可直接从docker hub获取镜像，并重新打tag为k8s.gcr.io的前缀，方便使用kubeadm部署</span></span><br><span class="line"><span class="comment"># kubeadm初始化的时候可以指定不使用官方gcr的仓库的镜像，使用我下面的配置可以省略以上拉镜像的步骤</span></span><br></pre></td></tr></table></figure>
<p><a name="911945df"></a></p>
<h5 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h5><p><strong>在第一个节点</strong>，首先创建一个配置文件 <code>kubeadm-config.yam</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.14.1</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">certSANs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"172.16.11.83"</span></span><br><span class="line"><span class="comment">#networking:</span></span><br><span class="line"><span class="comment">#  podSubnet: 192.168.0.0/16</span></span><br><span class="line"><span class="attr">controlPlaneEndpoint:</span> <span class="string">"172.16.11.83:6444"</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">imdingtalk</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeproxy.config.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeProxyConfiguration</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">"ipvs"</span></span><br></pre></td></tr></table></figure>
<p><strong>kubernetesVersion :</strong>  这个应该为kube的版本，我这里应该改为v1.13.2<br><strong>controlPlaneEndpoint：</strong>填写负载IP（VIP）或者dns。并加上端口<br>使用ipvs模式，需要加载内核模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line"><span class="comment">#配置内核设置</span></span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<p>确保环境是干净的，执行初始化命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --config=kubeadm-config.yaml</span><br></pre></td></tr></table></figure>
<p>如果顺利的话，你将看到这个输出：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1548163245690-c5205d26-0dc0-4e9f-b599-b0f1cc98382a.png#align=left&amp;display=inline&amp;height=328&amp;name=image.png&amp;originHeight=328&amp;originWidth=860&amp;size=38731&amp;status=done&amp;width=860" alt="image.png"><br>不要忘记执行输出中的提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>
<p>记下输出中的这一行，后面新加节点的时候需要用到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm join 10.10.0.144:6444 --token n90fm9.qsbd52sn4oc8qm4v --discovery-token-ca-cert-hash sha256:cdf01af0bbb5cdb1a7d4795ba357c97ef110430e35ed457c88de568454a8ef38</span><br></pre></td></tr></table></figure>
<p>以上执行成功后，集群的状态处于一个初始化的状态，需要给节点安装网络插件，才能正常可以用，这里我安装的是Weave 网络插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &apos;\n&apos;)&quot;</span><br><span class="line"># 过一会儿后检查状态</span><br><span class="line">kubectl get pod -n kube-system -w</span><br><span class="line"># 全部为running后执行接下来的事儿</span><br></pre></td></tr></table></figure>
<p>把证书文件拷贝到其他节点（<strong>注意：从1.14版本后，不需要接下来的操作，其他的节点基本都是join就完事儿了，不需要拷贝证书</strong>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">USER=ubuntu <span class="comment"># customizable</span></span><br><span class="line">CONTROL_PLANE_IPS=<span class="string">"10.0.0.7 10.0.0.8"</span></span><br><span class="line"><span class="keyword">for</span> host <span class="keyword">in</span> <span class="variable">$&#123;CONTROL_PLANE_IPS&#125;</span>; <span class="keyword">do</span></span><br><span class="line">    scp /etc/kubernetes/pki/ca.crt <span class="string">"<span class="variable">$&#123;USER&#125;</span>"</span>@<span class="variable">$host</span>:</span><br><span class="line">    scp /etc/kubernetes/pki/ca.key <span class="string">"<span class="variable">$&#123;USER&#125;</span>"</span>@<span class="variable">$host</span>:</span><br><span class="line">    scp /etc/kubernetes/pki/sa.key <span class="string">"<span class="variable">$&#123;USER&#125;</span>"</span>@<span class="variable">$host</span>:</span><br><span class="line">    scp /etc/kubernetes/pki/sa.pub <span class="string">"<span class="variable">$&#123;USER&#125;</span>"</span>@<span class="variable">$host</span>:</span><br><span class="line">    scp /etc/kubernetes/pki/front-proxy-ca.crt <span class="string">"<span class="variable">$&#123;USER&#125;</span>"</span>@<span class="variable">$host</span>:</span><br><span class="line">    scp /etc/kubernetes/pki/front-proxy-ca.key <span class="string">"<span class="variable">$&#123;USER&#125;</span>"</span>@<span class="variable">$host</span>:</span><br><span class="line">    scp /etc/kubernetes/pki/etcd/ca.crt <span class="string">"<span class="variable">$&#123;USER&#125;</span>"</span>@<span class="variable">$host</span>:etcd-ca.crt</span><br><span class="line">    scp /etc/kubernetes/pki/etcd/ca.key <span class="string">"<span class="variable">$&#123;USER&#125;</span>"</span>@<span class="variable">$host</span>:etcd-ca.key</span><br><span class="line">    scp /etc/kubernetes/admin.conf <span class="string">"<span class="variable">$&#123;USER&#125;</span>"</span>@<span class="variable">$host</span>:</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在其他节点，移动拷贝过来的文件到指定的目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">USER=ubuntu <span class="comment"># customizable</span></span><br><span class="line">mkdir -p /etc/kubernetes/pki/etcd</span><br><span class="line">mv /home/<span class="variable">$&#123;USER&#125;</span>/ca.crt /etc/kubernetes/pki/</span><br><span class="line">mv /home/<span class="variable">$&#123;USER&#125;</span>/ca.key /etc/kubernetes/pki/</span><br><span class="line">mv /home/<span class="variable">$&#123;USER&#125;</span>/sa.pub /etc/kubernetes/pki/</span><br><span class="line">mv /home/<span class="variable">$&#123;USER&#125;</span>/sa.key /etc/kubernetes/pki/</span><br><span class="line">mv /home/<span class="variable">$&#123;USER&#125;</span>/front-proxy-ca.crt /etc/kubernetes/pki/</span><br><span class="line">mv /home/<span class="variable">$&#123;USER&#125;</span>/front-proxy-ca.key /etc/kubernetes/pki/</span><br><span class="line">mv /home/<span class="variable">$&#123;USER&#125;</span>/etcd-ca.crt /etc/kubernetes/pki/etcd/ca.crt</span><br><span class="line">mv /home/<span class="variable">$&#123;USER&#125;</span>/etcd-ca.key /etc/kubernetes/pki/etcd/ca.key</span><br><span class="line">mv /home/<span class="variable">$&#123;USER&#125;</span>/admin.conf /etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure>
<p>接下来使用刚才记录下来的kubeadm   join 命令来加入到已经存在的节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm join 192.168.0.200:6443 --token j04n3m.octy8zely83cy2ts --discovery-token-ca-cert-hash sha256:84938d2a22203a8e56a787ec0c6ddad7bc7dbd52ebabc62fd5f4dbea72b14d1f --experimental-control-plane</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里的命令，在前面几下来的那个命令的后面加了 --experimental-control-plane 参数，这个参数会让新的节点以master的方式加入集群</span></span><br><span class="line"><span class="comment"># 查看新的节点的部署情况</span></span><br><span class="line">kubectl get pod -n kube-system -w</span><br></pre></td></tr></table></figure>
<p>如果顺利的话，会是以下输出：<br>可以看到，kubeadm  join  自动的使用证书给etcd的集群添加了member，然后使用静态pod启动了etcd，然后使当前节点，加入了集群作为master<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1548163943996-9efed915-5778-4948-b605-8b655432eb11.png#align=left&amp;display=inline&amp;height=383&amp;name=image.png&amp;originHeight=383&amp;originWidth=924&amp;size=52040&amp;status=done&amp;width=924" alt="image.png"></p>
<p>参考文档：<br><a href="https://kubernetes.io/docs/setup/independent/high-availability/#" target="_blank" rel="noopener">Creating Highly Available Clusters with kubeadm</a></p>
]]></content>
  </entry>
  <entry>
    <title>安装和配置kubectl</title>
    <url>/2019/01/20/yuque/%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEkubectl/</url>
    <content><![CDATA[<p><a name="2c94c2a7"></a></p>
<h4 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h4><p>配置国内的阿里源<br>CentOS / RHEL / Fedora :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<p>Debian / Ubuntu :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https</span><br><span class="line">curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - </span><br><span class="line">cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF  </span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure>
<p><a name="e655a410"></a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Debian / Ubuntu :<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install -y kubelet</span><br></pre></td></tr></table></figure></p>
<p>CentOS / RHEL / Fedora :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y kubelet</span><br></pre></td></tr></table></figure>
<p>或者使用二进制包：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取最新二进制包：</span></span><br><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl</span><br><span class="line">chmod +x ./kubectl</span><br><span class="line">sudo mv ./kubectl /usr/<span class="built_in">local</span>/bin/kubectl</span><br></pre></td></tr></table></figure></p>
<p><a name="37bf4d94"></a></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p><a name="46e22ebc"></a></p>
<h5 id="配置命令的自动补全："><a href="#配置命令的自动补全：" class="headerlink" title="配置命令的自动补全："></a>配置命令的自动补全：</h5><p>kubectl 包含有自动补全的功能，这可以省去很多的输入。<br>在CentOS Linux上，可能需要安装默认情况下未安装的bash-completion软件包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install bash-completion -y</span><br><span class="line"><span class="comment"># 添加自动补全到当前的shell</span></span><br><span class="line"><span class="built_in">source</span> &lt;(kubectl completion bash)</span><br><span class="line"><span class="comment"># 添加自动补全到用户的profile</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source &lt;(kubectl completion bash)"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>以上，就可以使用tab键补全kubectl的命令啦，大大的提高了效率</p>
]]></content>
  </entry>
  <entry>
    <title>解决使用Travis过程中报Permission denied的问题</title>
    <url>/2019/01/20/yuque/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8Travis%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8A%A5Permission%20denied%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a name="254dd6d2"></a></p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在尝试使用Travis来同步谷歌的仓库过程中，使用自己写的脚本，想要添加阿里云的k8s源，遇到报错如下:<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1547953462568-e96010fb-aa06-4d99-beff-6b2cce095a67.png#align=left&amp;display=inline&amp;height=308&amp;name=image.png&amp;originHeight=308&amp;originWidth=1014&amp;size=52694&amp;width=1014" alt="image.png"><br><a name="4b86211f"></a></p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>  需要在 <code>travis.yml</code>文件开头加上  <code>sudo:  required</code> 并且在需要执行的命令前加上sudo<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1547954117906-75bdb0ee-f015-482b-bec8-3e3c3f5c8f76.png#align=left&amp;display=inline&amp;height=223&amp;name=image.png&amp;originHeight=223&amp;originWidth=630&amp;size=16552&amp;width=630" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>PV的回收策略小探</title>
    <url>/2019/01/15/yuque/PV%E7%9A%84%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E5%B0%8F%E6%8E%A2/</url>
    <content><![CDATA[<p><a name="61a3ec66"></a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>回收策略一般在PV或者storageclass中申明，主要有三种策略：Delete  Retain  Recycle </p>
<p><a name="507829ed"></a></p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>一个典型的PV申明如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfspv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/nfs</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>此处挂载的是本地的nfs服务器，为了配合测试建立相应的PVC如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfspvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Giya</span></span><br></pre></td></tr></table></figure>
<p>执行以上两个yaml：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl  apply  -f nfs-pv.yaml</span><br><span class="line">kubectl  apply  -f nfs-pvc.yaml</span><br><span class="line"><span class="comment"># 查看pvc或者pvc可以看到他们已经绑定</span></span><br><span class="line">[root@node1 <span class="built_in">test</span>]<span class="comment"># kubectl  get pv</span></span><br><span class="line">NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM            STORAGECLASS   REASON   AGE</span><br><span class="line">nfspv   2Gi        RWO            Retain           Bound    default/nfspvc                           11s</span><br><span class="line"><span class="comment"># 可以看到名字为nfspvc的pvc申明需要的空间为1Gi，k8s自动匹配最相近的PV，所以匹配了名字</span></span><br><span class="line"><span class="comment"># 为nfspv的PV,提供了2Gi存储空间，满足了PVC的要求。</span></span><br></pre></td></tr></table></figure>
<p>使用一个POD来使用这PVC：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginxusepv</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">web-frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span>  <span class="string">claim1</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">"/usr/share/nginx/html"</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span>  <span class="string">claim1</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">nfspvc</span></span><br></pre></td></tr></table></figure>
<p>可以通过 <code>kubectl  describe  pod nginxus</code> 来查看pod的挂载信息，pvc被挂载到了pod内。在pod内创建一个文件<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1547564347858-ed4d9024-e770-431a-825f-46be02f34336.png#align=left&amp;display=inline&amp;height=115&amp;name=image.png&amp;originHeight=115&amp;originWidth=900&amp;size=12720&amp;width=900" alt="image.png"><br>删除该pod，PVC和PV均不受影响，保证了数据的持久化。<br>接下来尝试删除PVC<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1547563820722-fba8a045-5c18-4631-91b8-b9ed96a0cd35.png#align=left&amp;display=inline&amp;height=184&amp;name=image.png&amp;originHeight=184&amp;originWidth=852&amp;size=22774&amp;width=852" alt="image.png">发现PV的状态由Bound变为Released，由于策略为Retain，所以PV上的数据得以保留，Released无法再被新的pvc绑定，即使使用原来 的pvc再次申明，那么也会由于没有合适的PV绑定，pvc会一直处理pending状态<img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1547563958341-42913c32-249d-4c8a-99a8-eb34a72c8f58.png#align=left&amp;display=inline&amp;height=117&amp;name=image.png&amp;originHeight=117&amp;originWidth=855&amp;size=13597&amp;width=855" alt="image.png"><br>查看，挂载pod使用时候的pvc，发现路径下的文件保留了下来。即使手动删除pv，物理磁盘也不会删除pv申明下的文件。此时可以根据pv的describe 去查看文件的具体信息或删除文件<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1547564280034-161ab293-2d8b-4595-aa3e-fc5bf9b4a329.png#align=left&amp;display=inline&amp;height=87&amp;name=image.png&amp;originHeight=87&amp;originWidth=879&amp;size=9335&amp;width=879" alt="image.png"><br>接下来把回收策略分别改为：Delete  Recycle 重复以上操作。总结了以下</p>
<ol>
<li>在Retain策略下，删除PVC不会删除PV和物理空间，但是PVC和PV会解绑，PV状态变为released，进入不可绑定状态。 这时PV我感觉唯一的作用就是让我们可以知道他的物理空间在什么地方。</li>
<li>在Delete策略下，删除PVC的同时，会一同删除PV。同时在nfs类型的PV中不支持Delete，虽然会连同PV一起删除，但是不删除物理磁盘的数据；<a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes" target="_blank" rel="noopener">根据存储类型不同</a>，AWS EBS, GCE PD, Azure Disk, or OpenStack Cinder等存储卷会被删除</li>
<li>在Recycle 策略下，删除PVC会解除PVC和PV的绑定，同时回收PV使用的空间，删除PV申明下的物理磁盘，PV的状态会由bound变为released再变为available。此时该PV可以被绑定，下次有pvc再次再次请求PV的时候，便会再次绑定。</li>
<li>所有策略下，删除pod均不会解除PVC和PV的绑定，除非手动删除PVC</li>
<li>实际上，当前只有nfs和hostpath支持Recycle </li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1547565397364-cbca661a-3dc2-4c47-9147-1706c17ffda3.png#align=left&amp;display=inline&amp;height=175&amp;name=image.png&amp;originHeight=175&amp;originWidth=901&amp;size=24142&amp;width=901" alt="image.png"><br>  在Recycle 策略下，删除PVC后PV的状态变化</p>
]]></content>
  </entry>
  <entry>
    <title>k8s 使用kubeconfig和token访问集群</title>
    <url>/2019/01/14/yuque/k8s%20%E4%BD%BF%E7%94%A8kubeconfig%E5%92%8Ctoken%E8%AE%BF%E9%97%AE%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p><a name="a4d3b02a"></a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>kubectl命令访问集群时，默认情况下在$HOME/.kube目录下寻找名为config的配置文件，配置文件中包含集群API地址、端口号、证书等，kubectl据此建构访问集群的上下文。<br><a name="c931653c"></a></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>实际我们在使用中开发需要特定namespace的权限，并且不能有集群的远程权限，使用API访问集群，运维拥有集群的所有控制权，仅有一个集群，于是使用RBAC做权限控制。 制作kubeconfig，同时支持kubectl远程访问和通过token访问API。<br><a name="cbb060fd"></a></p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s -L -o /bin/cfssl https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 </span><br><span class="line">curl -s -L -o /bin/cfssljson https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 </span><br><span class="line">curl -s -L -o /bin/cfssl-certinfo https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 </span><br><span class="line">chmod +x /bin/cfssl*</span><br></pre></td></tr></table></figure>
<p>准备好证书请求文件</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat&gt; user-csr.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;USER&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<p><a name="63199eed"></a></p>
<h3 id="定义集群、用户、上下文"><a href="#定义集群、用户、上下文" class="headerlink" title="定义集群、用户、上下文"></a>定义集群、用户、上下文</h3><p>制作kubeconf主要有三步：</p>
<ol>
<li>为配置文件添加集群信息</li>
<li>为配置文件添加用户信息（token访问可忽略）</li>
<li>为配置文件添加上下文</li>
</ol>
<p>输入以下命令，将群集详细信息添加到配置文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config --kubeconfig=config-demo <span class="built_in">set</span>-cluster development --server=https://1.2.3.4 --certificate-authority=fake-ca-file</span><br><span class="line"><span class="comment"># 例如如下：</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-cluster kubernetes \</span><br><span class="line">--certificate-authority=/etc/kubernetes/cert/ca.pem \</span><br><span class="line">--embed-certs=<span class="literal">true</span> \</span><br><span class="line">--server=https://172.16.200.100:8443 \</span><br><span class="line">--kubeconfig=config-demo.kubeconfig</span><br></pre></td></tr></table></figure>
<p>将用户认证详细信息添加到配置文件中（如果使用token访问可忽略此步骤）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config --kubeconfig=config-demo <span class="built_in">set</span>-credentials developer --client-certificate=fake-cert-file --client-key=fake-key-seefile</span><br><span class="line"><span class="comment"># 例如如下</span></span><br><span class="line"><span class="comment"># 设置证书认证,如果使用token认证的话，建议忽略这一步</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-credentials devuser-sa-key \</span><br><span class="line">--client-certificate=/etc/kubernetes/cert/devuser-sa.pem \</span><br><span class="line">--client-key=/etc/kubernetes/cert/devuser-sa-key.pem \</span><br><span class="line">--embed-certs=<span class="literal">true</span> \</span><br><span class="line">--kubeconfig=devuser-sa.kubeconfig</span><br></pre></td></tr></table></figure>
<p>将上下文详细信息添加到配置文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置上下文参数</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-context kubernetes-dev \</span><br><span class="line">--cluster=kubernetes \</span><br><span class="line">--user=devuser- \</span><br><span class="line">--namespace=dev \</span><br><span class="line">--kubeconfig=config-demo.kubeconfig</span><br><span class="line"><span class="comment"># 设置上下文参数</span></span><br><span class="line">kubectl config <span class="built_in">set</span>-context kubernetes-test \</span><br><span class="line">--cluster=kubernetes \</span><br><span class="line">--user=devuser \</span><br><span class="line">--namespace=<span class="built_in">test</span> \</span><br><span class="line">--kubeconfig=config-demo.kubeconfig</span><br></pre></td></tr></table></figure>
<p>打开 <code>config-demo</code> 文件查看添加的详细信息。 也可以使用 <code>config view</code> 命令进行查看：<br><code>kubectl config --kubeconfig=config-demo view</code><br><a name="RoleBinding"></a></p>
<h3 id="RoleBinding"><a href="#RoleBinding" class="headerlink" title="RoleBinding"></a>RoleBinding</h3><p>如果我们想限制 developer用户的行为，需要使用 RBAC创建角色绑定以将该用户的行为限制在某个或某几个 namespace 空间范围内，例如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create rolebinding developer-admin-binding --clusterrole=admin --user=developer --namespace=dev</span><br></pre></td></tr></table></figure></p>
<p>如果有多个上下文，需要设置当前上下文：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config --kubeconfig=config-demo use-context</span><br></pre></td></tr></table></figure></p>
<p>以上就可以使用kubeconfig文件来访问我们的集群了，其中包含的 fake-ca-file 部分均需要替换对应的自己的用户的证书文件，下回补充该部分。<br><a name="588544ba"></a></p>
<h3 id="新增使用token访问集群"><a href="#新增使用token访问集群" class="headerlink" title="新增使用token访问集群"></a>新增使用token访问集群</h3><p>为指定namespace分配该namespace的最高权限，这通常是在为某个用户（组织或者个人）划分了namespace之后，需要给该用户创建token登陆kubernetes dashboard或者调用kubernetes API的时候使用。<br>每次创建了新的namespace下都会生成一个默认的token，名为<code>default-token-xxxx</code>。<code>default</code>就相当于该namespace下的一个用户，可以使用下面的命令给该用户分配该namespace的管理员权限。我们只需要给这个用户一个管理员的权限，然后使用他的token就可以了<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create rolebinding <span class="variable">$ROLEBINDING_NAME</span> --clusterrole=admin --serviceaccount=<span class="variable">$NAMESPACE</span>:default --namespace=<span class="variable">$NAMESPACE</span></span><br></pre></td></tr></table></figure></p>
<p>获取指定namespace的token：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl  get secret -n dev default-token-xxx</span><br></pre></td></tr></table></figure>
<p>不过不建议使用默认的sa，以下使用新增的sa来访问集群<br><a name="PxIjj"></a></p>
<h4 id="使用新增sa访问"><a href="#使用新增sa访问" class="headerlink" title="使用新增sa访问"></a>使用新增sa访问</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在指定的ns创建一个新的sa</span></span><br><span class="line">kubectl create serviceaccount dev -n dev </span><br><span class="line"><span class="comment">#查看相关的secret</span></span><br><span class="line">kubectl get serviceaccounts -n dev dev  -o yaml</span><br><span class="line"><span class="comment">#查看对应的secret</span></span><br><span class="line">kubectl get secret dev-token-1yvwg -o yaml</span><br><span class="line">kubectl create rolebinding <span class="variable">$ROLEBINDING_NAME</span> --clusterrole=admin --serviceaccount=<span class="variable">$NAMESPACE</span>:<span class="variable">$USER</span> --namespace=<span class="variable">$NAMESPACE</span></span><br><span class="line"><span class="comment">#这里列出的token是经过base64加密的，使用时候一定要解密</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"&#123;token&#125;"</span>  | base64 -d</span><br></pre></td></tr></table></figure>
<p>最后的kubeconf文件应该类似这样的(仅token):</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> <span class="string">REDACTED</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://172.16.200.100:8443</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">devuser-sa</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dev</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">kubernetes</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">test-user-default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-test</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">kubernetes-test</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">preferences:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">devuser-sa</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">token:</span> <span class="string">&#123;这里是很长的token&#125;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-user-default</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">token:</span> <span class="string">&#123;这里是很长的token&#125;</span></span><br></pre></td></tr></table></figure>
<p><a name="db06c78d"></a></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换当前上下文为kubernetes-dev</span></span><br><span class="line">[k8s@kube-node1 ~]$ kubectl  config  use-context kubernetes-dev </span><br><span class="line">Switched to context "kubernetes-dev".</span><br><span class="line">[k8s@kube-node1 ~]$ kubectl  get secret  -n dev  </span><br><span class="line">NAME                           TYPE                                  DATA      AGE</span><br><span class="line">dashboard-dev-sa-token-bjdqz   kubernetes.io/service-account-token   3         77d</span><br><span class="line">default-token-6th7g            kubernetes.io/service-account-token   3         77d</span><br><span class="line">[k8s@kube-node1 ~]$ kubectl  get secret  -n test</span><br><span class="line">Error from server (Forbidden): secrets is forbidden:xxx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换当前上下文为kubernetes-test</span></span><br><span class="line">[k8s@kube-node1 ~]$ kubectl  get secret  -n test</span><br><span class="line">NAME                            TYPE                                  DATA      AGE</span><br><span class="line">dashboard-test-sa-token-8r4vq   kubernetes.io/service-account-token   3         77d</span><br><span class="line">default-token-fzcwj             kubernetes.io/service-account-token   3         77d</span><br><span class="line"></span><br><span class="line">[k8s@kube-node1 ~]$ kubectl  get secret  -n dev</span><br><span class="line">Error from server (Forbidden): secrets is forbidden: User "system:serviceaccount:test:default" cannot list secrets in the namespace "dev"</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 测试通过</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试通过接口访问，替换命令中的token和API地址</span></span><br><span class="line">curl -s --cacert /etc/kubernetes/cert/ca.pem -H "Authorization: Bearer &#123;token&#125;"    https://&#123;IP&#125;:&#123;PORT&#125;/api/v1/namespaces/dev/secrets</span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有报错则通过</span></span><br></pre></td></tr></table></figure>
<p>参考<br><a href="https://jimmysong.io/kubernetes-handbook/concepts/rbac.html" target="_blank" rel="noopener">RBAC——基于角色的访问控制</a><br><a href="https://k8smeetup.github.io/docs/admin/authorization/rbac/" target="_blank" rel="noopener">Using RBAC Authorization</a>  <br><a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#users-in-kubernetes?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">Authenticating</a><br><a href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/" target="_blank" rel="noopener">Configure Access to Multiple Clusters</a></p>
]]></content>
  </entry>
  <entry>
    <title>Git出现 fatal  Pathspec xxx is in submodule 解决办法</title>
    <url>/2019/01/13/Git%E5%87%BA%E7%8E%B0%20fatal%20%20Pathspec%20xxx%20is%20in%20submodule%20%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>在给hexo换主题的过程中，使用的是git下载下来的next包,下载下来后使用 git add next/ 无法添加next的目录。<br>解决办法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 报错信息如下</span></span><br><span class="line">[root@iZwz96589vyznjacr6y3ayZ next]<span class="comment"># git add  * </span></span><br><span class="line">fatal: Path <span class="string">'themes/next/bower.json'</span> is <span class="keyword">in</span> submodule <span class="string">'themes/next'</span></span><br><span class="line"><span class="comment"># 处理办法</span></span><br><span class="line">git rm --cached themes/</span><br><span class="line">git add  themes  <span class="comment">#  现在就可以添加了</span></span><br></pre></td></tr></table></figure>
<p>还有一种情况可能是目录下有 <code>.git</code>  目录，删除该目录试试</p>
]]></content>
  </entry>
  <entry>
    <title>GitHub+Travis CI+hexo构建个人博客</title>
    <url>/2019/01/11/yuque/GitHub+Travis%20CI+hexo%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>参考文档:<br><a href>Hexo 博客终极玩法：云端写作，自动部署</a><br><a href="https://segmentfault.com/a/1190000013266001" target="_blank" rel="noopener">使用Hexo+Github+TravisCI搭建自动发布的静态博客系统</a><br><a href="https://juejin.im/post/5a1fa30c6fb9a045263b5d2a" target="_blank" rel="noopener">Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程</a></p>
<p>基本参考以上的文章做了完整的一套，此处不再赘诉，以下说下几个坑的地方：</p>
<ol>
<li>要使用 <a href="https://imdingtalk.github.io/">https://imdingtalk.github.io/</a> 这种以自己的用户GitHub用户名做域名（不用这种的话，可以使用自己的域名）的话，必须使用master分支做为展示页面。前面教程基本都是用master分支来做hexo源码存放路径的。搞得我后来把仓库名改成  <code>&lt;username&gt;.github.io</code>  之后，自动构建了半天结果页面还是404 。查看设置页面才知道有这坑，但是我前面已经将源码目录和生成后的页面分别放在了master和gh-pages，Google半天也不知道怎么搜索去切换master和gh-pages，自己摸索了下，抱着试一试的心态把远程仓库全部删除了。重新传了下代码解决。仅供参考<img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1547366132303-361d8219-7cbc-46ce-8bd7-0f0179a769cd.png#align=left&amp;display=inline&amp;height=266&amp;name=image.png&amp;originHeight=323&amp;originWidth=809&amp;size=27313&amp;status=done&amp;width=666" alt="image.png"></li>
</ol>
<p>做以下操作前，需要先<strong>关闭travis-ci</strong>的自动构建，避免push了删除的操作后，触发构建，导致代码混乱<br><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1547366878176-6fa846b2-0aad-4331-b122-edece2c0c798.png#align=left&amp;display=inline&amp;height=325&amp;name=image.png&amp;originHeight=325&amp;originWidth=1008&amp;size=27624&amp;status=done&amp;width=1008" alt="image.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远端下载最新的代码,进入代码目录</span></span><br><span class="line">git <span class="built_in">clone</span> xxx.git</span><br><span class="line"><span class="built_in">cd</span>  xxx</span><br><span class="line"><span class="comment"># 切换到主分支并备份主分支</span></span><br><span class="line">git  checkout master</span><br><span class="line">mkdir  ../master</span><br><span class="line">\cp -rf * ../master</span><br><span class="line"><span class="comment"># 切换到gh-pages分支并备份该分支</span></span><br><span class="line">git checkout gh-pages</span><br><span class="line">mkdir  ../ghpages</span><br><span class="line">\cp -rf * ../ghpages</span><br><span class="line"><span class="comment">#  目录备份完成，直接删除远程仓库代码</span></span><br><span class="line">git  rm -rf  *</span><br><span class="line">git commit -m <span class="string">"delete gh-pages"</span></span><br><span class="line">git push origin gh-pages</span><br><span class="line">git checkout master </span><br><span class="line">git  rm -rf  *</span><br><span class="line">git commit -m <span class="string">"delete master"</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment"># 以上就删除了远端目录，接下来把备份的gh-pages推到master，备份的master推送到gh-pages</span></span><br><span class="line"><span class="comment"># change  master to gh-pages</span></span><br><span class="line"><span class="built_in">cd</span> ../master</span><br><span class="line">git init</span><br><span class="line">git remote add origin  git@github.com:imdingtalk/imdingtalk.github.io.git </span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"change  master to gh-pages"</span></span><br><span class="line">git push origin gh-pages  --force <span class="comment">#这里必须加 --force 否则会提示要首先同步远程仓库,远程仓库在前面的操作中已经删完了，千万别同步下来了</span></span><br><span class="line"><span class="comment">#  change   gh-pages to master </span></span><br><span class="line"><span class="built_in">cd</span> ghpages </span><br><span class="line">git init</span><br><span class="line">git remote add origin  git@github.com:imdingtalk/imdingtalk.github.io.git</span><br><span class="line"><span class="comment"># 本地创建新分支</span></span><br><span class="line">git branch  -b gh-pages</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">"change gh-pages to  master "</span></span><br><span class="line">git push origin gh-pages  --force</span><br></pre></td></tr></table></figure>
<p>以上，便完成了分支的转换，应该有更方便的办法，我没找到，献丑啦。<br>这样改需要对应的修改hexo的 <code>_config.yml</code>  和 <code>.travis.yml</code>   </p>
<p><code>.travis.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>
<p><code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://GH_TOKEN@github.com/imdingtalk/imdingtalk.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>确认无误后打开Travis CI的自动构建<br><a name="0d98c747"></a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>获取Travis的仓库id，在serverless的时候使用  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L http://api.travis-ci.org/repos/imdingtalk/imdingtalk.github.io</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/148941/1551316679279-5cf0f52b-9cbe-4ffb-9cf3-3d8c1f664356.png#align=left&amp;display=inline&amp;height=222&amp;name=image.png&amp;originHeight=224&amp;originWidth=754&amp;size=60254&amp;status=done&amp;width=746" alt="image.png"><br>将以上获取的信息添加到无服务函数作为参数  </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main_handler</span><span class="params">($event, $context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析语雀post的数据</span></span><br><span class="line">    $update_title = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">if</span>($event-&gt;body)&#123;</span><br><span class="line">        $yuque_data= json_decode($event-&gt;body);</span><br><span class="line">        $update_title .= $yuque_data-&gt;data-&gt;title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// default params</span></span><br><span class="line">    $repos = <span class="string">'imdingtalk%2FBlog'</span>;  <span class="comment">// 你的仓库id 或 slug  这里%2F代替imdingtalk/Blog中的/或替换为返回结果中的id 8575778</span></span><br><span class="line">    $token = <span class="string">'a-pHmOiaVy8RUXKXm5fWYQ'</span>; <span class="comment">// 你的登录token,travis的token</span></span><br><span class="line">    $message = date(<span class="string">"Y/m/d"</span>).<span class="string">':yuque update:'</span>.$update_title;</span><br><span class="line">    $branch = <span class="string">'master'</span>;</span><br><span class="line">    <span class="comment">// post params</span></span><br><span class="line">    $queryString = $event-&gt;queryString;</span><br><span class="line">    $q_token = $queryString-&gt;token ? $queryString-&gt;token : $token;</span><br><span class="line">    $q_repos = $queryString-&gt;repos ? $queryString-&gt;repos : $repos;</span><br><span class="line">    $q_message = $queryString-&gt;message ? $queryString-&gt;message : $message;</span><br><span class="line">    $q_branch = $queryString-&gt;branch ? $queryString-&gt;branch : <span class="string">'master'</span>;</span><br><span class="line">    <span class="keyword">echo</span>($q_token);</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">'==='</span>);</span><br><span class="line">    <span class="keyword">echo</span> ($q_repos);</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">'==='</span>);</span><br><span class="line">    <span class="keyword">echo</span> ($q_message);</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">'==='</span>);</span><br><span class="line">    <span class="keyword">echo</span> ($q_branch);</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">'==='</span>);</span><br><span class="line">    <span class="comment">//request travis ci</span></span><br><span class="line">    $res_info = triggerTravisCI($q_repos, $q_token, $q_message, $q_branch);</span><br><span class="line">    <span class="keyword">echo</span> ($res_info);</span><br><span class="line">    $res_code = <span class="number">0</span>;</span><br><span class="line">    $res_message = <span class="string">'未知'</span>;</span><br><span class="line">    <span class="keyword">if</span>($res_info[<span class="string">'http_code'</span>])&#123;</span><br><span class="line">        $res_code = $res_info[<span class="string">'http_code'</span>];</span><br><span class="line">        <span class="keyword">switch</span>($res_info[<span class="string">'http_code'</span>])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">202</span>:</span><br><span class="line">                $res_message = <span class="string">'success'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                $res_message = <span class="string">'faild'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $res = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'status'</span>=&gt;$res_code,</span><br><span class="line">        <span class="string">'message'</span>=&gt;$res_message</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> $res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>  travis api , trigger a build</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $repos string 仓库ID、slug</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $token string 登录验证token</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $message string 触发信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> $branch string 分支</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> $info array 回包信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">triggerTravisCI</span> <span class="params">($repos, $token, $message=<span class="string">'yuque update'</span>, $branch=<span class="string">'gh-pages'</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    $curl = curl_init();</span><br><span class="line">    <span class="comment">//设置抓取的url</span></span><br><span class="line">    curl_setopt($curl, CURLOPT_URL, <span class="string">'https://api.travis-ci.com/repo/'</span>.$repos.<span class="string">'/requests'</span>);</span><br><span class="line">    <span class="comment">//设置获取的信息以文件流的形式返回，而不是直接输出。</span></span><br><span class="line">    curl_setopt($curl, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//设置post方式提交</span></span><br><span class="line">    curl_setopt($curl, CURLOPT_CUSTOMREQUEST, <span class="string">"POST"</span>);</span><br><span class="line">    <span class="comment">//设置post数据</span></span><br><span class="line">    $post_data = json_encode(<span class="keyword">array</span>(</span><br><span class="line">        <span class="string">"request"</span>=&gt; <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">"message"</span>=&gt;$message,</span><br><span class="line">            <span class="string">"branch"</span>=&gt;$branch</span><br><span class="line">        )</span><br><span class="line">    ));</span><br><span class="line">    $header = <span class="keyword">array</span>(</span><br><span class="line">      <span class="string">'Content-Type: application/json'</span>,</span><br><span class="line">      <span class="string">'Travis-API-Version: 3'</span>,</span><br><span class="line">      <span class="string">'Authorization:token '</span>.$token,</span><br><span class="line">      <span class="string">'Content-Length:'</span> . strlen($post_data)</span><br><span class="line">    );</span><br><span class="line">    curl_setopt($curl, CURLOPT_HTTPHEADER, $header);</span><br><span class="line">    curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data);</span><br><span class="line">    <span class="comment">//执行命令</span></span><br><span class="line">    $data = curl_exec($curl);</span><br><span class="line">    $info = curl_getinfo($curl);</span><br><span class="line">    <span class="comment">//关闭URL请求</span></span><br><span class="line">    curl_close($curl);</span><br><span class="line">    <span class="keyword">return</span> $info;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
